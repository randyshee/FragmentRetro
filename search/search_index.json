{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FragmentRetro: A Quadratic Retrosynthetic Method Based on Fragmentation Algorithms","text":"<p>FragmentRetro is a fragment-based retrosynthetic method with quadratic complexity, offering a scalable alternative to tree search and DirectMultiStep.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>You can install the package after cloning the repo:</p> <pre><code>uv venv --python 3.11.4\nsource .venv/bin/activate\nuv pip install -e .\n</code></pre>"},{"location":"#preprocess-stocks","title":"Preprocess Stocks","text":"<p>To precompute properties and pattern fingerprints for faster screening, run the following commands:</p> <pre><code>python data/process_buyables.py\npython data/process_stock.py\n</code></pre>"},{"location":"#usage-example","title":"Usage Example","text":"<p>Here's a quick example to obtain retrosynthesis solutions:</p> <pre><code>from pathlib import Path\nfrom fragmentretro.fragmenter import BRICSFragmenter  # or rBRICSFragmenter\nfrom fragmentretro.retrosynthesis import Retrosynthesis\nfrom fragmentretro.solutions import RetrosynthesisSolution\n\nDATA_PATH = Path(__name__).parent / \"data\"\nPAROUTES_PATH = DATA_PATH / \"paroutes\"\nPRECOMPUTE_PATH = DATA_PATH / \"precompute\"\nJSON_PRECOMPUTE_PATH = PRECOMPUTE_PATH / \"n1_stock_properties.json\"\n\ntarget = \"COc1ccc(F)c(-c2ccc(COc3cccc(C(CC(=O)O)C4CC4)c3)nc2CC(C)(C)C)c1\"\nfragmenter = BRICSFragmenter(target) # or rBRICSFragmenter\nretro_tool = Retrosynthesis(fragmenter, original_BBs=None, mol_properties_path=JSON_PRECOMPUTE_PATH)\nretro_tool.fragment_retrosynthesis()\nretro_solution = RetrosynthesisSolution(retro_tool)\nretro_solution.fill_solutions()\nall_img = retro_solution.visualize_solutions(retro_solution.solutions)\n\n# visualize first solution or simply run this in a notebook: all_img[0]\n# with open(\"output.png\", \"wb\") as f:\n#     f.write(all_img[0].data)\n\n# Or in a python script\n# all_img[0].save(\"output.png\", format=\"PNG\")\n</code></pre>"},{"location":"#graphical-user-interface-gui","title":"Graphical User Interface (GUI)","text":"<p>FragmentRetro's Graphical User Interface (GUI) is built using <code>ipywidget</code>. To access the GUI within a Jupyter notebook:</p> <pre><code>from app.interface import display_gui\n\nimport logging\nfrom fragmentretro.utils.logging_config import logger as fragment_logger\nfrom app.logging_config import logger as app_logger\n\n# Adjust the logging levels to control the verbosity of the logs or to suppress them\nfragment_logger.setLevel(logging.WARNING)\napp_logger.setLevel(logging.INFO) \n\n# To display the GUI without any initial SMILES input\napp = display_gui()\n\n# Alternatively, to display the GUI with a predefined SMILES string\napp = display_gui(smiles=\"CCNCC\")\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>We welcome any contributions, feel free to clone the repo and create a PR. We recommend using uv:</p> <pre><code>uv venv --python 3.11.4\nsource .venv/bin/activate\nuv pip install -e \".[dev]\"\n</code></pre>"},{"location":"#license","title":"License","text":"<ul> <li>Code: MIT License</li> <li>Paper content (arXiv preprint): CC-BY 4.0</li> </ul>"},{"location":"FragmentRetro/fragmenter-base/","title":"Base Class for Fragmenter","text":""},{"location":"FragmentRetro/fragmenter-base/#example-use","title":"Example Use","text":"<p>You will only have to define the abstract methods to find fragmentation bonds and to break these bonds. Other methods like building fragment graph (<code>networkx</code> graph), visualization, and how to get SMILES string given a combination of fragments are provided in this base class.</p> <pre><code>from fragmentretro.fragmenter_base import Fragmenter\n\n# suppose you have a new way to find and break bonds: `FindTestBonds` and `BreakTestBonds`\n\nclass TestFragmenter(Fragmenter):\n    def __init__(self, smiles: str) -&gt; None:\n        \"\"\"\n        Initialize with SMILES string.\n\n        Args:\n            smiles: SMILES string of molecule to fragment\n        \"\"\"\n        super().__init__(smiles)\n\n    def _find_fragmentation_bonds(self, mol: Mol) -&gt; list[BondType]:\n        return FindTestBonds(mol)\n\n    def _break_bonds(self, mol: Mol, bonds: list[BondType]) -&gt; Mol:\n        return BreakTestBonds(mol, bonds)\n</code></pre>"},{"location":"FragmentRetro/fragmenter-base/#source-code","title":"Source Code","text":""},{"location":"FragmentRetro/fragmenter-base/#fragmentretro.fragmenter_base","title":"<code>fragmentretro.fragmenter_base</code>","text":""},{"location":"FragmentRetro/fragmenter-base/#fragmentretro.fragmenter_base.Fragmenter","title":"<code>Fragmenter</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src/fragmentretro/fragmenter_base.py</code> <pre><code>class Fragmenter(ABC):\n    def __init__(self, smiles: str) -&gt; None:\n        self.original_smiles: str = smiles\n        self.original_mol: Mol = Chem.MolFromSmiles(smiles)\n        self.fragmentation_bonds: list[BondType] = self._find_fragmentation_bonds(self.original_mol)\n        self.broken_mol: Mol = self._break_bonds(self.original_mol, self.fragmentation_bonds)\n        self.atom_mappings: list[AtomMappingType] = []\n        self.fragment_graph: nx.Graph = self._build_fragment_graph()\n        self.num_fragments: int = len(self.fragment_graph.nodes())\n\n    @abstractmethod\n    def _find_fragmentation_bonds(self, mol: Mol) -&gt; list[BondType]:\n        pass\n\n    @abstractmethod\n    def _break_bonds(self, mol: Mol, bonds: list[BondType]) -&gt; Mol:\n        pass\n\n    def _build_fragment_graph(self) -&gt; nx.Graph:\n        \"\"\"\n        Build graph representing fragment connectivity.\n        Nodes are fragments with their SMILES and atom mappings.\n        Edges contain bond type information.\n        Uses Graph to support only one edge between fragments.\n\n        Returns:\n            NetworkX Graph representing fragment connectivity\n        \"\"\"\n        G = nx.Graph()\n\n        mol_fragments: tuple[Mol] = Chem.GetMolFrags(\n            self.broken_mol, asMols=True, fragsMolAtomMapping=self.atom_mappings\n        )\n\n        atom_to_frag = {}\n        for frag_id, atom_indices in enumerate(self.atom_mappings):\n            for atom_idx in atom_indices:\n                atom_to_frag[atom_idx] = frag_id\n\n        for i, fragment in enumerate(mol_fragments):\n            G.add_node(i, smiles=Chem.MolToSmiles(fragment), atom_indices=self.atom_mappings[i])\n\n        edge_index = 0\n        for (atom1, atom2), (type1, type2) in self.fragmentation_bonds:\n            frag1 = atom_to_frag.get(atom1)\n            frag2 = atom_to_frag.get(atom2)\n\n            if (frag1 != frag2) and (frag1 is not None) and (frag2 is not None) and not G.has_edge(frag1, frag2):\n                G.add_edge(\n                    frag1,\n                    frag2,\n                    bond_type=(type1, type2),\n                    atoms=(atom1, atom2),\n                    edge_index=edge_index,\n                )\n                edge_index += 1\n\n        return G\n\n    def _get_initial_fragments(self) -&gt; list[str]:\n        \"\"\"\n        Retrieve the initial fragments as SMILES strings from the fragment graph.\n\n        Returns:\n            List of SMILES strings representing the initial fragments.\n        \"\"\"\n        return [self.fragment_graph.nodes[node][\"smiles\"] for node in self.fragment_graph.nodes()]\n\n    def visualize(\n        self,\n        figsize: tuple[float, float] = (10.0, 10.0),\n        with_indices: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Visualize the fragment graph and optionally print detailed information.\n        Handles multiple edges between nodes.\n        \"\"\"\n        pos = nx.spring_layout(self.fragment_graph)\n        plt.figure(figsize=figsize)\n\n        # Draw nodes\n        nx.draw_networkx_nodes(self.fragment_graph, pos, node_color=\"lightblue\", node_size=2000)\n\n        # Draw edges without curves since we only have single edges\n        for edge in self.fragment_graph.edges(data=True):\n            u, v, data = edge\n            nx.draw_networkx_edges(\n                self.fragment_graph,\n                pos,\n                edgelist=[(u, v)],\n            )\n\n        # Add node labels\n        labels = {\n            node: f\"Node {node}: {data['smiles']}\" if with_indices else data[\"smiles\"]\n            for node, data in self.fragment_graph.nodes(data=True)\n        }\n        nx.draw_networkx_labels(self.fragment_graph, pos, labels)\n\n        # Add edge labels\n        edge_labels = {\n            (u, v): f\"Edge {data['edge_index']} ({u}-{v}): {data['bond_type']}\"\n            if with_indices\n            else f\"{data['bond_type']}\"\n            for u, v, data in self.fragment_graph.edges(data=True)\n        }\n\n        for (u, v), label in edge_labels.items():\n            x = (pos[u][0] + pos[v][0]) / 2\n            y = (pos[u][1] + pos[v][1]) / 2\n            plt.text(\n                x,\n                y,\n                label,\n                bbox=dict(facecolor=\"white\", edgecolor=\"none\", alpha=0.7),\n                horizontalalignment=\"center\",\n                verticalalignment=\"center\",\n            )\n\n        plt.title(\"Fragment Connectivity Graph\")\n        plt.axis(\"off\")\n        plt.show()\n\n        logger.info(\"[Fragmenter] \\nNode data:\")\n        for node in self.fragment_graph.nodes():\n            logger.info(f\"[Fragmenter] \\nNode {node}:\")\n            logger.info(f\"[Fragmenter] SMILES: {self.fragment_graph.nodes[node]['smiles']}\")\n            logger.info(f\"[Fragmenter] Atom indices: {self.fragment_graph.nodes[node]['atom_indices']}\")\n\n        logger.info(\"[Fragmenter] \\nEdge data:\")\n        for u, v, data in self.fragment_graph.edges(data=True):\n            logger.info(f\"[Fragmenter] \\nEdge {data['edge_index']} ({u}-{v}):\")\n            logger.info(f\"[Fragmenter] Bond type: {data['bond_type']}\")\n            logger.info(f\"[Fragmenter] Atoms: {data['atoms']}\")\n\n    def get_length_n_combinations(self, n: int) -&gt; set[CombType]:\n        \"\"\"\n        Get all unique combinations of n fragments in the fragment graph.\n\n        Args:\n            n: Length of combinations to find\n\n        Returns:\n            Set of unique combinations as sorted lists of node IDs\n        \"\"\"\n        all_combinations = set()\n\n        def dfs(path: list[int], candidates: set[int]) -&gt; None:\n            if len(path) == n:\n                sorted_path = cast(CombType, tuple(sorted(path)))\n                all_combinations.add(sorted_path)\n                return\n\n            for node in candidates:\n                if node not in path:\n                    new_candidates = candidates | set(self.fragment_graph.neighbors(node)) - set(path)\n                    dfs(path + [node], new_candidates)\n\n        for node in self.fragment_graph.nodes:\n            dfs([node], set(self.fragment_graph.neighbors(node)))\n\n        return all_combinations\n\n    def get_length_n_combinations_from_last_stage(self, last_combinations: list[CombType]) -&gt; set[CombType]:\n        \"\"\"Generate combinations of fragments extending from the previous stage.\n\n        This method takes a list of combinations from a previous stage and generates\n        new combinations by adding one neighboring fragment to each combination.\n\n        Args:\n            last_combinations: A list of tuples, where each tuple represents a combination\n                               of fragment node IDs from the previous stage.\n\n        Returns:\n            A set of unique combinations (as sorted tuples of node IDs) generated by\n            extending the combinations from the previous stage.\n        \"\"\"\n\n        # n = len(list(last_combinations)[0]) + 1\n        all_combinations = set()\n\n        for last_comb in last_combinations:\n            for node in last_comb:\n                for neighbor in self.fragment_graph.neighbors(node):\n                    last_comb_copy = set(last_comb).copy()  # turn tuple into set\n                    if neighbor not in last_comb_copy:\n                        last_comb_copy.add(neighbor)\n                        sorted_comb = cast(CombType, tuple(sorted(list(last_comb_copy))))\n                        all_combinations.add(sorted_comb)\n\n        return all_combinations\n\n    def check_connected_subgraph(self, combination: CombType) -&gt; bool:\n        \"\"\"Check if the combination is a connected subgraph of the original molecule.\n\n        Args:\n            check_subgraph: Whether to check if the combination is a connected subgraph of the original molecule.\n\n        Returns:\n            True if the combination is a connected subgraph, False otherwise.\n\n        \"\"\"\n        # check if the combination is a connected subgraph\n        subgraph = self.fragment_graph.subgraph(combination)\n        return cast(bool, nx.is_connected(subgraph))\n\n    def get_combination_smiles(self, combination: CombType) -&gt; str:\n        \"\"\"\n        Get the fragment smiles given one combination.\n\n        Args:\n            combination: A combination as a sorted list of node IDs.\n\n        Returns:\n            A SMILES string representing the fragment combination.\n        \"\"\"\n        if len(combination) == 0:\n            return \"\"\n        elif len(combination) == 1:\n            return cast(str, self.fragment_graph.nodes[combination[0]][\"smiles\"])\n        elif len(combination) == self.num_fragments:\n            return self.original_smiles\n\n        # remove the bonds that are within the fragment combination\n        bonds_to_break: list[BondType] = self.fragmentation_bonds.copy()\n        for pair in itertools.combinations(combination, 2):\n            edge_data = self.fragment_graph.get_edge_data(*pair)\n            if edge_data:\n                bonds_to_break.remove((edge_data[\"atoms\"], edge_data[\"bond_type\"]))\n        # break the bonds\n        comb_broken_mol = self._break_bonds(self.original_mol, bonds_to_break)\n        comb_atom_mappings: list[AtomMappingType] = []\n        mol_fragments: tuple[Mol] = Chem.GetMolFrags(\n            comb_broken_mol, asMols=True, fragsMolAtomMapping=comb_atom_mappings\n        )\n        # get the smiles with the atom mapping that contains the first atom of the combination\n        # first atom is chosen since it is always not the bond break (i.e. any or *) atom\n        for i, mol in enumerate(mol_fragments):\n            if self.atom_mappings[combination[0]][0] in comb_atom_mappings[i]:\n                comb_smiles = Chem.MolToSmiles(mol)\n                break\n        return cast(str, comb_smiles)\n</code></pre>"},{"location":"FragmentRetro/fragmenter-base/#fragmentretro.fragmenter_base.Fragmenter.visualize","title":"<code>visualize(figsize=(10.0, 10.0), with_indices=False)</code>","text":"<p>Visualize the fragment graph and optionally print detailed information. Handles multiple edges between nodes.</p> Source code in <code>src/fragmentretro/fragmenter_base.py</code> <pre><code>def visualize(\n    self,\n    figsize: tuple[float, float] = (10.0, 10.0),\n    with_indices: bool = False,\n) -&gt; None:\n    \"\"\"\n    Visualize the fragment graph and optionally print detailed information.\n    Handles multiple edges between nodes.\n    \"\"\"\n    pos = nx.spring_layout(self.fragment_graph)\n    plt.figure(figsize=figsize)\n\n    # Draw nodes\n    nx.draw_networkx_nodes(self.fragment_graph, pos, node_color=\"lightblue\", node_size=2000)\n\n    # Draw edges without curves since we only have single edges\n    for edge in self.fragment_graph.edges(data=True):\n        u, v, data = edge\n        nx.draw_networkx_edges(\n            self.fragment_graph,\n            pos,\n            edgelist=[(u, v)],\n        )\n\n    # Add node labels\n    labels = {\n        node: f\"Node {node}: {data['smiles']}\" if with_indices else data[\"smiles\"]\n        for node, data in self.fragment_graph.nodes(data=True)\n    }\n    nx.draw_networkx_labels(self.fragment_graph, pos, labels)\n\n    # Add edge labels\n    edge_labels = {\n        (u, v): f\"Edge {data['edge_index']} ({u}-{v}): {data['bond_type']}\"\n        if with_indices\n        else f\"{data['bond_type']}\"\n        for u, v, data in self.fragment_graph.edges(data=True)\n    }\n\n    for (u, v), label in edge_labels.items():\n        x = (pos[u][0] + pos[v][0]) / 2\n        y = (pos[u][1] + pos[v][1]) / 2\n        plt.text(\n            x,\n            y,\n            label,\n            bbox=dict(facecolor=\"white\", edgecolor=\"none\", alpha=0.7),\n            horizontalalignment=\"center\",\n            verticalalignment=\"center\",\n        )\n\n    plt.title(\"Fragment Connectivity Graph\")\n    plt.axis(\"off\")\n    plt.show()\n\n    logger.info(\"[Fragmenter] \\nNode data:\")\n    for node in self.fragment_graph.nodes():\n        logger.info(f\"[Fragmenter] \\nNode {node}:\")\n        logger.info(f\"[Fragmenter] SMILES: {self.fragment_graph.nodes[node]['smiles']}\")\n        logger.info(f\"[Fragmenter] Atom indices: {self.fragment_graph.nodes[node]['atom_indices']}\")\n\n    logger.info(\"[Fragmenter] \\nEdge data:\")\n    for u, v, data in self.fragment_graph.edges(data=True):\n        logger.info(f\"[Fragmenter] \\nEdge {data['edge_index']} ({u}-{v}):\")\n        logger.info(f\"[Fragmenter] Bond type: {data['bond_type']}\")\n        logger.info(f\"[Fragmenter] Atoms: {data['atoms']}\")\n</code></pre>"},{"location":"FragmentRetro/fragmenter-base/#fragmentretro.fragmenter_base.Fragmenter.get_length_n_combinations","title":"<code>get_length_n_combinations(n)</code>","text":"<p>Get all unique combinations of n fragments in the fragment graph.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Length of combinations to find</p> required <p>Returns:</p> Type Description <code>set[CombType]</code> <p>Set of unique combinations as sorted lists of node IDs</p> Source code in <code>src/fragmentretro/fragmenter_base.py</code> <pre><code>def get_length_n_combinations(self, n: int) -&gt; set[CombType]:\n    \"\"\"\n    Get all unique combinations of n fragments in the fragment graph.\n\n    Args:\n        n: Length of combinations to find\n\n    Returns:\n        Set of unique combinations as sorted lists of node IDs\n    \"\"\"\n    all_combinations = set()\n\n    def dfs(path: list[int], candidates: set[int]) -&gt; None:\n        if len(path) == n:\n            sorted_path = cast(CombType, tuple(sorted(path)))\n            all_combinations.add(sorted_path)\n            return\n\n        for node in candidates:\n            if node not in path:\n                new_candidates = candidates | set(self.fragment_graph.neighbors(node)) - set(path)\n                dfs(path + [node], new_candidates)\n\n    for node in self.fragment_graph.nodes:\n        dfs([node], set(self.fragment_graph.neighbors(node)))\n\n    return all_combinations\n</code></pre>"},{"location":"FragmentRetro/fragmenter-base/#fragmentretro.fragmenter_base.Fragmenter.get_length_n_combinations_from_last_stage","title":"<code>get_length_n_combinations_from_last_stage(last_combinations)</code>","text":"<p>Generate combinations of fragments extending from the previous stage.</p> <p>This method takes a list of combinations from a previous stage and generates new combinations by adding one neighboring fragment to each combination.</p> <p>Parameters:</p> Name Type Description Default <code>last_combinations</code> <code>list[CombType]</code> <p>A list of tuples, where each tuple represents a combination                of fragment node IDs from the previous stage.</p> required <p>Returns:</p> Type Description <code>set[CombType]</code> <p>A set of unique combinations (as sorted tuples of node IDs) generated by</p> <code>set[CombType]</code> <p>extending the combinations from the previous stage.</p> Source code in <code>src/fragmentretro/fragmenter_base.py</code> <pre><code>def get_length_n_combinations_from_last_stage(self, last_combinations: list[CombType]) -&gt; set[CombType]:\n    \"\"\"Generate combinations of fragments extending from the previous stage.\n\n    This method takes a list of combinations from a previous stage and generates\n    new combinations by adding one neighboring fragment to each combination.\n\n    Args:\n        last_combinations: A list of tuples, where each tuple represents a combination\n                           of fragment node IDs from the previous stage.\n\n    Returns:\n        A set of unique combinations (as sorted tuples of node IDs) generated by\n        extending the combinations from the previous stage.\n    \"\"\"\n\n    # n = len(list(last_combinations)[0]) + 1\n    all_combinations = set()\n\n    for last_comb in last_combinations:\n        for node in last_comb:\n            for neighbor in self.fragment_graph.neighbors(node):\n                last_comb_copy = set(last_comb).copy()  # turn tuple into set\n                if neighbor not in last_comb_copy:\n                    last_comb_copy.add(neighbor)\n                    sorted_comb = cast(CombType, tuple(sorted(list(last_comb_copy))))\n                    all_combinations.add(sorted_comb)\n\n    return all_combinations\n</code></pre>"},{"location":"FragmentRetro/fragmenter-base/#fragmentretro.fragmenter_base.Fragmenter.check_connected_subgraph","title":"<code>check_connected_subgraph(combination)</code>","text":"<p>Check if the combination is a connected subgraph of the original molecule.</p> <p>Parameters:</p> Name Type Description Default <code>check_subgraph</code> <p>Whether to check if the combination is a connected subgraph of the original molecule.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the combination is a connected subgraph, False otherwise.</p> Source code in <code>src/fragmentretro/fragmenter_base.py</code> <pre><code>def check_connected_subgraph(self, combination: CombType) -&gt; bool:\n    \"\"\"Check if the combination is a connected subgraph of the original molecule.\n\n    Args:\n        check_subgraph: Whether to check if the combination is a connected subgraph of the original molecule.\n\n    Returns:\n        True if the combination is a connected subgraph, False otherwise.\n\n    \"\"\"\n    # check if the combination is a connected subgraph\n    subgraph = self.fragment_graph.subgraph(combination)\n    return cast(bool, nx.is_connected(subgraph))\n</code></pre>"},{"location":"FragmentRetro/fragmenter-base/#fragmentretro.fragmenter_base.Fragmenter.get_combination_smiles","title":"<code>get_combination_smiles(combination)</code>","text":"<p>Get the fragment smiles given one combination.</p> <p>Parameters:</p> Name Type Description Default <code>combination</code> <code>CombType</code> <p>A combination as a sorted list of node IDs.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A SMILES string representing the fragment combination.</p> Source code in <code>src/fragmentretro/fragmenter_base.py</code> <pre><code>def get_combination_smiles(self, combination: CombType) -&gt; str:\n    \"\"\"\n    Get the fragment smiles given one combination.\n\n    Args:\n        combination: A combination as a sorted list of node IDs.\n\n    Returns:\n        A SMILES string representing the fragment combination.\n    \"\"\"\n    if len(combination) == 0:\n        return \"\"\n    elif len(combination) == 1:\n        return cast(str, self.fragment_graph.nodes[combination[0]][\"smiles\"])\n    elif len(combination) == self.num_fragments:\n        return self.original_smiles\n\n    # remove the bonds that are within the fragment combination\n    bonds_to_break: list[BondType] = self.fragmentation_bonds.copy()\n    for pair in itertools.combinations(combination, 2):\n        edge_data = self.fragment_graph.get_edge_data(*pair)\n        if edge_data:\n            bonds_to_break.remove((edge_data[\"atoms\"], edge_data[\"bond_type\"]))\n    # break the bonds\n    comb_broken_mol = self._break_bonds(self.original_mol, bonds_to_break)\n    comb_atom_mappings: list[AtomMappingType] = []\n    mol_fragments: tuple[Mol] = Chem.GetMolFrags(\n        comb_broken_mol, asMols=True, fragsMolAtomMapping=comb_atom_mappings\n    )\n    # get the smiles with the atom mapping that contains the first atom of the combination\n    # first atom is chosen since it is always not the bond break (i.e. any or *) atom\n    for i, mol in enumerate(mol_fragments):\n        if self.atom_mappings[combination[0]][0] in comb_atom_mappings[i]:\n            comb_smiles = Chem.MolToSmiles(mol)\n            break\n    return cast(str, comb_smiles)\n</code></pre>"},{"location":"FragmentRetro/fragmenter/","title":"Derived Class for Fragmenter","text":"<p>Once you have the fragmentation algorithms such as BRICS, you can get derived class from Fragmenter base class.</p>"},{"location":"FragmentRetro/fragmenter/#example-use","title":"Example Use","text":"<pre><code>from fragmentretro.fragmenter import BRICSFragmenter\n\nsmiles = \"COc1ccc(-n2nccn2)c(C(=O)N2CCC[C@@]2(C)c2nc3c(C)c(Cl)ccc3[nH]2)c1\"\nfragmenter = BRICSFragmenter(smiles)\n\n# Custom figure size\nfragmenter.visualize(figsize=(20, 10), verbose=False, with_indices=True)\n</code></pre>"},{"location":"FragmentRetro/fragmenter/#source-code","title":"Source Code","text":""},{"location":"FragmentRetro/fragmenter/#fragmentretro.fragmenter","title":"<code>fragmentretro.fragmenter</code>","text":"<p>Module for fragmenting molecules using BRICS (add other algorithms later).</p>"},{"location":"FragmentRetro/fragmenter/#fragmentretro.fragmenter.BRICSFragmenter","title":"<code>BRICSFragmenter</code>","text":"<p>               Bases: <code>Fragmenter</code></p> Source code in <code>src/fragmentretro/fragmenter.py</code> <pre><code>class BRICSFragmenter(Fragmenter):\n    def __init__(self, smiles: str) -&gt; None:\n        \"\"\"\n        Initialize with SMILES string.\n\n        Args:\n            smiles: SMILES string of molecule to fragment\n        \"\"\"\n        super().__init__(smiles)\n\n    def _find_fragmentation_bonds(self, mol: Mol) -&gt; list[BondType]:\n        return list(FindBRICSBonds(mol))\n\n    def _break_bonds(self, mol: Mol, bonds: list[BondType]) -&gt; Mol:\n        return BreakBRICSBonds(mol, bonds)\n</code></pre>"},{"location":"FragmentRetro/fragmenter/#fragmentretro.fragmenter.BRICSFragmenter.__init__","title":"<code>__init__(smiles)</code>","text":"<p>Initialize with SMILES string.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>SMILES string of molecule to fragment</p> required Source code in <code>src/fragmentretro/fragmenter.py</code> <pre><code>def __init__(self, smiles: str) -&gt; None:\n    \"\"\"\n    Initialize with SMILES string.\n\n    Args:\n        smiles: SMILES string of molecule to fragment\n    \"\"\"\n    super().__init__(smiles)\n</code></pre>"},{"location":"FragmentRetro/fragmenter/#fragmentretro.fragmenter.rBRICSFragmenter","title":"<code>rBRICSFragmenter</code>","text":"<p>               Bases: <code>Fragmenter</code></p> Source code in <code>src/fragmentretro/fragmenter.py</code> <pre><code>class rBRICSFragmenter(Fragmenter):\n    def __init__(self, smiles: str) -&gt; None:\n        \"\"\"\n        Initialize with SMILES string.\n\n        Args:\n            smiles: SMILES string of molecule to fragment\n        \"\"\"\n        super().__init__(smiles)\n\n    def _find_fragmentation_bonds(self, mol: Mol) -&gt; list[BondType]:\n        return list(find_brics_bonds(mol))  # type: ignore[no-untyped-call]\n\n    def _break_bonds(self, mol: Mol, bonds: list[BondType]) -&gt; Mol:\n        return break_r_brics_bonds(mol, bonds)  # type: ignore[no-untyped-call]\n</code></pre>"},{"location":"FragmentRetro/fragmenter/#fragmentretro.fragmenter.rBRICSFragmenter.__init__","title":"<code>__init__(smiles)</code>","text":"<p>Initialize with SMILES string.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>SMILES string of molecule to fragment</p> required Source code in <code>src/fragmentretro/fragmenter.py</code> <pre><code>def __init__(self, smiles: str) -&gt; None:\n    \"\"\"\n    Initialize with SMILES string.\n\n    Args:\n        smiles: SMILES string of molecule to fragment\n    \"\"\"\n    super().__init__(smiles)\n</code></pre>"},{"location":"FragmentRetro/retrosynthesis/","title":"Retrosynthesis","text":"<p>The <code>Retrosynthesis</code> class identifies all possible retrosynthesis solutions for a given molecule (after the valid fragment combinations are passed to the <code>RetrosynthesisSolution</code> class). It uses a fragmenter to break down the molecule into fragments, then recombines these fragments in every possible way, checking each combination against a set of allowed building blocks.</p>"},{"location":"FragmentRetro/retrosynthesis/#example-use","title":"Example Use","text":"<pre><code>from fragmentretro.fragmenter import BRICSFragmenter\nfrom fragmentretro.retrosynthesis import Retrosynthesis\nfrom fragmentretro.solutions import RetrosynthesisSolution\n\n# Define your building block set (SMILES strings)\noriginal_BBs = set(['Brc1cc(OC)ccc1-n1nccn1',\n                    'BrC(Br)=O',\n                    'BrN1CCC[C@@]1(Br)C',\n                    'Brc1nc2c(C)c(Cl)ccc2[nH]1'])\n\n# Initialize a fragmenter with the target SMILES\ntarget = \"COc1ccc(-n2nccn2)c(C(=O)N2CCC[C@@]2(C)c2nc3c(C)c(Cl)ccc3[nH]2)c1\"\nfragmenter = BRICSFragmenter(target)\n\n# Initialize the retrosynthesis tool with the fragmenter and building blocks\nretro_tool = Retrosynthesis(fragmenter, original_BBs)\n\n# Run the retrosynthesis algorithm\nretro_tool.fragment_retrosynthesis()\n\n# Pass the retrosynthesis tool to the solution tool to process the results\nretro_solution = RetrosynthesisSolution(retro_tool)\nretro_solution.fill_solutions()\nprint(retro_solution.solutions)\n# Expected output:\n# [[(0,), (1,), (2,), (3,), (4,), (5,)],\n#  [(0, 1), (2,), (3,), (4,), (5,)],\n#  [(0,), (1, 2), (3,), (4,), (5,)],\n#  [(0, 1, 2), (3,), (4,), (5,)]]\n\n# Visualize the last solution\nretro_solution.visualize_solutions(retro_solution.solutions, molsPerRow=4)[-1]\n\n# Get the valid building blocks for a fragment combination \n# retro_tool.comb_bbs_dict[(0, 1 ,2)]\n</code></pre>"},{"location":"FragmentRetro/retrosynthesis/#source-code","title":"Source Code","text":""},{"location":"FragmentRetro/retrosynthesis/#fragmentretro.retrosynthesis","title":"<code>fragmentretro.retrosynthesis</code>","text":""},{"location":"FragmentRetro/retrosynthesis/#fragmentretro.retrosynthesis.Retrosynthesis","title":"<code>Retrosynthesis</code>","text":"Source code in <code>src/fragmentretro/retrosynthesis.py</code> <pre><code>class Retrosynthesis:\n    def __init__(\n        self,\n        fragmenter: Fragmenter,\n        original_BBs: BBsType | None = None,\n        mol_properties_path: Path | None = None,\n        fpSize: int = 2048,\n        parallelize: bool = False,\n        num_cores: int | None = None,\n        core_factor: int = 10,\n        compound_filter: CompoundFilter | None = None,\n    ):\n        self.fragmenter = fragmenter\n        self.num_fragments = fragmenter.num_fragments\n        self.valid_combinations_dict: StageCombDictType = {}  # store valid combs for each stage\n        self.invalid_combinations_dict: StageCombDictType = {}  # store invalid combs for each stage\n        self.comb_bbs_dict: CombBBsDictType = {}  # store valid BBs for fragment combs\n        self.fragment_bbs_dict: FragmentBBsDictType = {}  # store valid BBs for fragments SMILES\n        self.parallelize = parallelize\n        self.num_cores = num_cores\n        self.core_factor = core_factor\n        self.last_stage_combs: list[CombType]\n\n        if original_BBs is not None and mol_properties_path is not None:\n            logger.warn(\"Both original_BBs and mol_properties_path are provided. Will be using mol_properties_path.\")\n        elif mol_properties_path is not None and compound_filter is not None:\n            logger.warn(\"Both mol_properties_path and compound_filter are provided. Will be using compound_filter.\")\n        elif original_BBs is None and mol_properties_path is None and compound_filter is None:\n            logger.critical(\"Either original_BBs, mol_properties_path, or compound_filter must be provided.\")\n        if mol_properties_path is not None:\n            self.use_filter = True\n            self.fpSize = fpSize\n            self.compound_filter = compound_filter\n            if self.compound_filter is None:\n                self.compound_filter = CompoundFilter(mol_properties_path, fpSize=self.fpSize)\n            self.comb_filter_indices_dict: CombFilterIndicesDictType = {}\n        else:\n            self.use_filter = False\n            self.original_BBs = original_BBs\n\n    def _check_effective_comb(self, comb: CombType) -&gt; bool:\n        \"\"\"Check if a combination is effective.\n\n        A combination is considered effective if it does not contain any\n        invalid combinations from the previous stage. Note that only effective\n        combinations could become a valid combination.\n\n        Args:\n            comb: The combination to check, represented as a tuple of fragment indices.\n\n        Returns:\n            True if the combination is effective, False otherwise.\n        \"\"\"\n        len_comb = len(comb)\n        len_minus_one_invalid_combs = self.invalid_combinations_dict.get(len_comb - 1, [])\n        return all(not set(invalid_comb).issubset(set(comb)) for invalid_comb in len_minus_one_invalid_combs)\n\n    def _get_prefiltered_indices(self, comb: CombType) -&gt; FilterIndicesType | None:\n        \"\"\"Get prefiltered indices for a given combination.\n\n        This method retrieves a list of prefiltered indices based on valid\n        combinations from the previous stage that are subsets of the current\n        combination.  It's used for efficient filtering when using molecular\n        properties.\n\n        Args:\n            comb: The combination to get prefiltered indices for, represented as a\n                tuple of fragment indices.\n\n        Returns:\n            A list of prefiltered indices, or None if the combination is of\n            length 1 or no prefiltered indices are found.\n        \"\"\"\n        len_comb = len(comb)\n        len_minus_one_valid_combs = self.valid_combinations_dict.get(len_comb - 1, [])\n        if len_comb == 1:\n            return None\n        else:\n            prefiltered_set: set[int] = set()\n            for valid_comb in len_minus_one_valid_combs:\n                if set(valid_comb).issubset(set(comb)):\n                    if not prefiltered_set:\n                        prefiltered_set = set(self.comb_filter_indices_dict[valid_comb])\n                    else:\n                        prefiltered_set = prefiltered_set.intersection(self.comb_filter_indices_dict[valid_comb])\n        return list(prefiltered_set)\n\n    def _get_possible_BBs_for_comb_no_filter(self, comb: CombType) -&gt; BBsType:\n        len_comb = len(comb)\n        if len_comb == 1:\n            return cast(BBsType, self.original_BBs)\n        len_minus_one_valid_combs = self.valid_combinations_dict.get(len_comb - 1, [])\n        BBs: BBsType = set()\n        for valid_comb in len_minus_one_valid_combs:\n            if set(valid_comb).issubset(set(comb)):\n                if not BBs:\n                    BBs = self.comb_bbs_dict[valid_comb]\n                else:\n                    BBs = BBs.intersection(self.comb_bbs_dict[valid_comb])\n        return BBs\n\n    def _get_possible_BBs_for_comb(self, comb: CombType) -&gt; BBsType:\n        \"\"\"Get possible building blocks for a given combination of fragments.\n\n        For a combination of length 1, the original building blocks are returned.\n        For combinations of length greater than 1, the building blocks are\n        retrieved by intersecting the building blocks of valid combinations from\n        the previous stage that are subsets of the current combination.\n\n        Args:\n            comb: The combination to get building blocks for, represented as a\n                tuple of fragment indices.\n\n        Returns:\n            A set of SMILES strings representing the building blocks for the\n            given combination.\n        \"\"\"\n        if not self.use_filter:\n            return self._get_possible_BBs_for_comb_no_filter(comb)\n        elif self.compound_filter is not None:\n            comb_smiles = self.fragmenter.get_combination_smiles(comb)\n            prefiltered_indices = self._get_prefiltered_indices(comb)\n            filtered_indices, filtered_BBs = self.compound_filter.get_filtered_BBs(comb_smiles, prefiltered_indices)\n            self.comb_filter_indices_dict[comb] = filtered_indices\n            if len(comb) == 1:\n                return filtered_BBs\n            else:\n                possible_BBs = self._get_possible_BBs_for_comb_no_filter(comb)\n                logger.info(\n                    f\"[Retrosynthesis] Number of possible BBs (when no filter) for {comb_smiles}: {len(possible_BBs)}\"\n                )\n                return possible_BBs.intersection(filtered_BBs)\n        else:\n            logger.error(\"[Retrosynthesis] Using filtering but compound filter is missing\")\n            raise ValueError(\"[Retrosynthesis] Using filtering but compound filter is missing d\")\n\n    def _retro_stage(self, stage: int) -&gt; tuple[int, int]:\n        \"\"\"Perform retrosynthesis for a single stage.\n\n        This method performs the retrosynthesis process for a given stage. It\n        generates combinations of fragments, checks their effectiveness,\n        identifies valid combinations based on building block matching, and\n        stores the results.\n\n        Args:\n            stage: The current retrosynthesis stage (an integer).\n        Returns:\n            A tuple containing the number of valid and invalid combinations at the given stage.\n        \"\"\"\n        self.valid_combinations_dict[stage] = []\n        # get fragment comb for stage\n        if stage == 1:\n            combs = list(self.fragmenter.get_length_n_combinations(stage))\n            self.last_stage_combs = combs\n        else:\n            combs = list(self.fragmenter.get_length_n_combinations_from_last_stage(self.last_stage_combs))\n            self.last_stage_combs = combs\n\n        logger.info(f\"[Retrosynthesis] Stage {stage}: {len(combs)} combinations\")\n        # check invalid comb and filter out effective comb\n        effective_combs, invalid_combs = [], []\n        for comb in combs:\n            if self._check_effective_comb(comb):\n                effective_combs.append(comb)\n            else:\n                invalid_combs.append(comb)\n        self.invalid_combinations_dict[stage] = invalid_combs\n        logger.info(f\"[Retrosynthesis] Stage {stage}: {len(effective_combs)} effective combinations\")\n\n        for comb in effective_combs:\n            fragment_smiles = self.fragmenter.get_combination_smiles(comb)\n            fragment_smiles_without_indices = remove_indices_before_dummy(fragment_smiles)\n            # get building blocks for comb\n            if fragment_smiles_without_indices in self.fragment_bbs_dict:\n                logger.info(\n                    f\"[Retrosynthesis] Fragment {fragment_smiles} ( {fragment_smiles_without_indices} ) already processed\"\n                )\n                previous_comb, valid_BBs = self.fragment_bbs_dict[fragment_smiles_without_indices]\n                # have to store filtered indices as what's done in `_get_possible_BBs_for_comb`\n                self.comb_filter_indices_dict[comb] = self.comb_filter_indices_dict[previous_comb]\n            else:\n                possible_comb_BBs = self._get_possible_BBs_for_comb(comb)\n                logger.info(f\"[Retrosynthesis] Number of possible BBs for {fragment_smiles}: {len(possible_comb_BBs)}\")\n                comb_matcher = SubstructureMatcher(\n                    possible_comb_BBs,\n                    parallelize=self.parallelize,\n                    num_cores=self.num_cores,\n                    core_factor=self.core_factor,\n                )\n                valid_BBs = comb_matcher.get_substructure_BBs(fragment_smiles)\n                self.fragment_bbs_dict[fragment_smiles_without_indices] = (comb, valid_BBs)\n\n            # store valid comb and BBs\n            if len(valid_BBs) &gt; 0:\n                self.valid_combinations_dict[stage].append(comb)\n                self.comb_bbs_dict[comb] = valid_BBs\n            else:\n                self.invalid_combinations_dict[stage].append(comb)\n        stage_valid_count = len(self.valid_combinations_dict[stage])\n        stage_invalid_count = len(self.invalid_combinations_dict[stage])\n        logger.info(f\"[Retrosynthesis] Stage {stage}: {stage_valid_count} valid combinations\")\n        logger.info(f\"[Retrosynthesis] Stage {stage}: {stage_invalid_count} invalid combinations\")\n        return stage_valid_count, stage_invalid_count\n\n    def fragment_retrosynthesis(self) -&gt; StageCombDictType:\n        \"\"\"Perform retrosynthesis on the molecule.\n\n        This method orchestrates the retrosynthesis process by iteratively\n        applying the `_retro_stage` method for each stage, starting from stage 1\n        up to the total number of fragments.\n\n        Returns:\n            A dictionary containing the valid combinations for each stage.\n            The keys are the stage numbers (integers), and the values are lists\n            of valid combinations (tuples of fragment indices).\n        \"\"\"\n        for stage in range(1, self.num_fragments + 1):\n            stage_valid_count, stage_invalid_count = self._retro_stage(stage)\n            if stage_valid_count == 0 or (stage == 1 and stage_invalid_count &gt; 0):\n                logger.info(f\"[Retrosynthesis] Stopped at stage {stage}\")\n                break\n        if self.use_filter:\n            # save memory\n            del self.compound_filter\n            del self.comb_filter_indices_dict\n        del self.fragment_bbs_dict\n        return self.valid_combinations_dict\n</code></pre>"},{"location":"FragmentRetro/retrosynthesis/#fragmentretro.retrosynthesis.Retrosynthesis.fragment_retrosynthesis","title":"<code>fragment_retrosynthesis()</code>","text":"<p>Perform retrosynthesis on the molecule.</p> <p>This method orchestrates the retrosynthesis process by iteratively applying the <code>_retro_stage</code> method for each stage, starting from stage 1 up to the total number of fragments.</p> <p>Returns:</p> Type Description <code>StageCombDictType</code> <p>A dictionary containing the valid combinations for each stage.</p> <code>StageCombDictType</code> <p>The keys are the stage numbers (integers), and the values are lists</p> <code>StageCombDictType</code> <p>of valid combinations (tuples of fragment indices).</p> Source code in <code>src/fragmentretro/retrosynthesis.py</code> <pre><code>def fragment_retrosynthesis(self) -&gt; StageCombDictType:\n    \"\"\"Perform retrosynthesis on the molecule.\n\n    This method orchestrates the retrosynthesis process by iteratively\n    applying the `_retro_stage` method for each stage, starting from stage 1\n    up to the total number of fragments.\n\n    Returns:\n        A dictionary containing the valid combinations for each stage.\n        The keys are the stage numbers (integers), and the values are lists\n        of valid combinations (tuples of fragment indices).\n    \"\"\"\n    for stage in range(1, self.num_fragments + 1):\n        stage_valid_count, stage_invalid_count = self._retro_stage(stage)\n        if stage_valid_count == 0 or (stage == 1 and stage_invalid_count &gt; 0):\n            logger.info(f\"[Retrosynthesis] Stopped at stage {stage}\")\n            break\n    if self.use_filter:\n        # save memory\n        del self.compound_filter\n        del self.comb_filter_indices_dict\n    del self.fragment_bbs_dict\n    return self.valid_combinations_dict\n</code></pre>"},{"location":"FragmentRetro/solutions/","title":"Retrosynthesis Solution","text":"<p>The <code>RetrosynthesisSolution</code> class is designed to find and visualize all possible retrosynthesis solutions given a set of fragmented molecules and their valid combinations. <code>Retrosynthesis</code> class is used to get valid combinations of fragments and <code>Fragmenter</code> class is used to obtain the fragment SMILES for visualization.</p>"},{"location":"FragmentRetro/solutions/#example-use","title":"Example Use","text":"<pre><code>from fragmentretro.retrosynthesis import Retrosynthesis\nfrom fragmentretro.fragmenter import BRICSFragmenter\nfrom fragmentretro.solutions import RetrosynthesisSolution\n\n# Example SMILES\nsmiles = \"COc1ccc(-n2nccn2)c(C(=O)N2CCC[C@@]2(C)c2nc3c(C)c(Cl)ccc3[nH]2)c1\"\nfragmenter = BRICSFragmenter(smiles)\n\nretro_tool = Retrosynthesis(fragmenter=fragmenter, original_BBs=set())\n\n# no need to run retrosynthesis for this example usage\n# will give an example solution in the next few lines\n# retro_tool.fragment_retrosynthesis \n\n# Example Solution\nretro_solution = RetrosynthesisSolution(retro_tool)\nretro_solution.solutions = [[[0, 1, 2], [3], [4], [5]]]\n\n# Visualize solutions\nimages = retro_solution.visualize_solutions(retro_solution.solutions, molsPerRow=4)\nfor i, img in enumerate(images):\n    img.save(f\"solution_{i}.png\")\n    print(f\"Solution {i} saved to solution_{i}.png\")\n</code></pre>"},{"location":"FragmentRetro/solutions/#source-code","title":"Source Code","text":""},{"location":"FragmentRetro/solutions/#fragmentretro.solutions","title":"<code>fragmentretro.solutions</code>","text":""},{"location":"FragmentRetro/solutions/#fragmentretro.solutions.RetrosynthesisSolution","title":"<code>RetrosynthesisSolution</code>","text":"Source code in <code>src/fragmentretro/solutions.py</code> <pre><code>class RetrosynthesisSolution:\n    def __init__(self, retrosynthesis: Retrosynthesis):\n        self.retrosynthesis = retrosynthesis\n        self.fragmenter = retrosynthesis.fragmenter\n        self.solutions: list[SolutionType] = []\n        self.valid_combinations = list(chain.from_iterable(retrosynthesis.valid_combinations_dict.values()))\n        self.valid_combinations = sorted(self.valid_combinations, key=len, reverse=True)\n        self.num_fragments = retrosynthesis.fragmenter.num_fragments\n\n    @staticmethod\n    def _find_complementary_combinations(\n        current_solution: list[CombType],\n        remaining_fragments: set[int],\n        start_index: int,\n        valid_combinations: list[CombType],\n        all_solutions: list[SolutionType],\n    ) -&gt; None:\n        \"\"\"\n        Recursively finds complementary combinations to form a complete solution.\n\n        Args:\n            current_solution: The current partial solution.\n            remaining_fragments: The set of fragments that still need to be covered.\n            start_index: The index to start searching for combinations from.\n            valid_combinations: The list of valid fragment combinations.\n            all_solutions: The list to store complete solutions.\n        \"\"\"\n        if not remaining_fragments:\n            sorted_solution = sorted(current_solution, key=lambda s: sorted(s))\n            if sorted_solution not in all_solutions:\n                all_solutions.append(sorted_solution)\n            return\n\n        for j in range(start_index, len(valid_combinations)):\n            comb2 = valid_combinations[j]\n            if set(comb2).issubset(remaining_fragments):\n                RetrosynthesisSolution._find_complementary_combinations(\n                    current_solution + [comb2],\n                    remaining_fragments - set(comb2),\n                    j + 1,\n                    valid_combinations,\n                    all_solutions,\n                )\n\n    @staticmethod\n    def get_solutions(\n        valid_combinations: list[CombType], num_fragments: int, solution_cap: int | None = None\n    ) -&gt; list[SolutionType]:\n        \"\"\"\n        Generates all possible retrosynthesis solutions from a list of valid fragment combinations.\n\n        A valid solution is defined as a combination of fragment lists that, when combined,\n        include all the original fragments exactly once.\n\n        Args:\n            valid_combinations: A list of valid fragment combinations, where each combination\n                is a tuple of fragment indices.\n            num_fragments: The total number of fragments in the retrosynthesis.\n            solution_cap: An optional integer specifying the maximum number of solutions to return.\n\n        Returns:\n            A list of retrosynthesis solutions. Each solution is a list of fragment lists.\n            Returns an empty list if no solutions are found.\n        \"\"\"\n        all_solutions: list[SolutionType] = []\n        full_fragment_set = set(range(num_fragments))\n\n        for i, comb1 in enumerate(valid_combinations):\n            solution = [comb1]\n            remaining_fragments = full_fragment_set - set(comb1)\n\n            if not remaining_fragments:\n                sorted_solution = sorted(solution, key=lambda s: sorted(s))\n                if sorted_solution not in all_solutions:\n                    all_solutions.append(sorted_solution)\n                continue\n\n            RetrosynthesisSolution._find_complementary_combinations(\n                solution, remaining_fragments, i + 1, valid_combinations, all_solutions\n            )\n            if solution_cap and len(all_solutions) &gt;= solution_cap:\n                logger.info(f\"[RetrosynthesisSolution] Solution count capped at {solution_cap}\")\n                return all_solutions[:solution_cap]\n\n        return all_solutions\n\n    def fill_solutions(self, solution_cap: int | None = None) -&gt; None:\n        \"\"\"Fill the solutions list with all possible solutions.\"\"\"\n        self.solutions = self.get_solutions(self.valid_combinations, self.num_fragments, solution_cap)\n\n    def get_solution_smiles(self, solution: SolutionType) -&gt; list[str]:\n        \"\"\"\n        Retrieves the SMILES strings for each combination in a given solution.\n\n        Args:\n            solution: A retrosynthesis solution, which is a list of fragment combinations.\n                      Each combination is a tuple of fragment indices.\n\n        Returns:\n            A list of SMILES strings, where each string corresponds to a fragment\n            combination in the solution.\n        \"\"\"\n        all_smiles = []\n        for comb in solution:\n            smiles = self.fragmenter.get_combination_smiles(comb)\n            all_smiles.append(smiles)\n        return all_smiles\n\n    def visualize_solutions(\n        self, solutions: list[SolutionType], molsPerRow: int = 3, subImgSize: tuple[float, float] = (200, 200)\n    ) -&gt; list[Image.Image]:\n        \"\"\"Visualizes a list of retrosynthesis solutions.\n\n        Generates a list of images, where each image visualizes a single retrosynthesis\n        solution. Each solution is displayed as a grid of molecules, with the SMILES\n        strings of the molecules as legends.\n\n        Args:\n            solutions: A list of retrosynthesis solutions. Each solution is a list of\n                fragment combinations (lists of fragment indices).\n            molsPerRow: The number of molecules to display in each row of the grid.\n            subImgSize: The size (width, height) of each molecule image in the grid.\n\n        Returns:\n            A list of PIL Image objects, each visualizing a retrosynthesis solution.\n        \"\"\"\n        all_img = []\n        for solution in solutions:\n            logger.info(f\"[RetrosynthesisSolution] Solution: {solution}\")\n            all_smiles = self.get_solution_smiles(solution)\n            logger.info(f\"[RetrosynthesisSolution] SMILES: {all_smiles}\")\n            # Convert SMILES to RDKit molecules\n            mols = [Chem.MolFromSmiles(smiles) for smiles in all_smiles]\n            # Draw molecules in a grid\n            legends = [f\"{comb}: {smiles}\" for comb, smiles in zip(solution, all_smiles, strict=False)]\n            img = Draw.MolsToGridImage(mols, molsPerRow=molsPerRow, subImgSize=subImgSize, legends=legends)\n            all_img.append(img)\n        return all_img\n</code></pre>"},{"location":"FragmentRetro/solutions/#fragmentretro.solutions.RetrosynthesisSolution.get_solutions","title":"<code>get_solutions(valid_combinations, num_fragments, solution_cap=None)</code>  <code>staticmethod</code>","text":"<p>Generates all possible retrosynthesis solutions from a list of valid fragment combinations.</p> <p>A valid solution is defined as a combination of fragment lists that, when combined, include all the original fragments exactly once.</p> <p>Parameters:</p> Name Type Description Default <code>valid_combinations</code> <code>list[CombType]</code> <p>A list of valid fragment combinations, where each combination is a tuple of fragment indices.</p> required <code>num_fragments</code> <code>int</code> <p>The total number of fragments in the retrosynthesis.</p> required <code>solution_cap</code> <code>int | None</code> <p>An optional integer specifying the maximum number of solutions to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[SolutionType]</code> <p>A list of retrosynthesis solutions. Each solution is a list of fragment lists.</p> <code>list[SolutionType]</code> <p>Returns an empty list if no solutions are found.</p> Source code in <code>src/fragmentretro/solutions.py</code> <pre><code>@staticmethod\ndef get_solutions(\n    valid_combinations: list[CombType], num_fragments: int, solution_cap: int | None = None\n) -&gt; list[SolutionType]:\n    \"\"\"\n    Generates all possible retrosynthesis solutions from a list of valid fragment combinations.\n\n    A valid solution is defined as a combination of fragment lists that, when combined,\n    include all the original fragments exactly once.\n\n    Args:\n        valid_combinations: A list of valid fragment combinations, where each combination\n            is a tuple of fragment indices.\n        num_fragments: The total number of fragments in the retrosynthesis.\n        solution_cap: An optional integer specifying the maximum number of solutions to return.\n\n    Returns:\n        A list of retrosynthesis solutions. Each solution is a list of fragment lists.\n        Returns an empty list if no solutions are found.\n    \"\"\"\n    all_solutions: list[SolutionType] = []\n    full_fragment_set = set(range(num_fragments))\n\n    for i, comb1 in enumerate(valid_combinations):\n        solution = [comb1]\n        remaining_fragments = full_fragment_set - set(comb1)\n\n        if not remaining_fragments:\n            sorted_solution = sorted(solution, key=lambda s: sorted(s))\n            if sorted_solution not in all_solutions:\n                all_solutions.append(sorted_solution)\n            continue\n\n        RetrosynthesisSolution._find_complementary_combinations(\n            solution, remaining_fragments, i + 1, valid_combinations, all_solutions\n        )\n        if solution_cap and len(all_solutions) &gt;= solution_cap:\n            logger.info(f\"[RetrosynthesisSolution] Solution count capped at {solution_cap}\")\n            return all_solutions[:solution_cap]\n\n    return all_solutions\n</code></pre>"},{"location":"FragmentRetro/solutions/#fragmentretro.solutions.RetrosynthesisSolution.fill_solutions","title":"<code>fill_solutions(solution_cap=None)</code>","text":"<p>Fill the solutions list with all possible solutions.</p> Source code in <code>src/fragmentretro/solutions.py</code> <pre><code>def fill_solutions(self, solution_cap: int | None = None) -&gt; None:\n    \"\"\"Fill the solutions list with all possible solutions.\"\"\"\n    self.solutions = self.get_solutions(self.valid_combinations, self.num_fragments, solution_cap)\n</code></pre>"},{"location":"FragmentRetro/solutions/#fragmentretro.solutions.RetrosynthesisSolution.get_solution_smiles","title":"<code>get_solution_smiles(solution)</code>","text":"<p>Retrieves the SMILES strings for each combination in a given solution.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>SolutionType</code> <p>A retrosynthesis solution, which is a list of fragment combinations.       Each combination is a tuple of fragment indices.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of SMILES strings, where each string corresponds to a fragment</p> <code>list[str]</code> <p>combination in the solution.</p> Source code in <code>src/fragmentretro/solutions.py</code> <pre><code>def get_solution_smiles(self, solution: SolutionType) -&gt; list[str]:\n    \"\"\"\n    Retrieves the SMILES strings for each combination in a given solution.\n\n    Args:\n        solution: A retrosynthesis solution, which is a list of fragment combinations.\n                  Each combination is a tuple of fragment indices.\n\n    Returns:\n        A list of SMILES strings, where each string corresponds to a fragment\n        combination in the solution.\n    \"\"\"\n    all_smiles = []\n    for comb in solution:\n        smiles = self.fragmenter.get_combination_smiles(comb)\n        all_smiles.append(smiles)\n    return all_smiles\n</code></pre>"},{"location":"FragmentRetro/solutions/#fragmentretro.solutions.RetrosynthesisSolution.visualize_solutions","title":"<code>visualize_solutions(solutions, molsPerRow=3, subImgSize=(200, 200))</code>","text":"<p>Visualizes a list of retrosynthesis solutions.</p> <p>Generates a list of images, where each image visualizes a single retrosynthesis solution. Each solution is displayed as a grid of molecules, with the SMILES strings of the molecules as legends.</p> <p>Parameters:</p> Name Type Description Default <code>solutions</code> <code>list[SolutionType]</code> <p>A list of retrosynthesis solutions. Each solution is a list of fragment combinations (lists of fragment indices).</p> required <code>molsPerRow</code> <code>int</code> <p>The number of molecules to display in each row of the grid.</p> <code>3</code> <code>subImgSize</code> <code>tuple[float, float]</code> <p>The size (width, height) of each molecule image in the grid.</p> <code>(200, 200)</code> <p>Returns:</p> Type Description <code>list[Image]</code> <p>A list of PIL Image objects, each visualizing a retrosynthesis solution.</p> Source code in <code>src/fragmentretro/solutions.py</code> <pre><code>def visualize_solutions(\n    self, solutions: list[SolutionType], molsPerRow: int = 3, subImgSize: tuple[float, float] = (200, 200)\n) -&gt; list[Image.Image]:\n    \"\"\"Visualizes a list of retrosynthesis solutions.\n\n    Generates a list of images, where each image visualizes a single retrosynthesis\n    solution. Each solution is displayed as a grid of molecules, with the SMILES\n    strings of the molecules as legends.\n\n    Args:\n        solutions: A list of retrosynthesis solutions. Each solution is a list of\n            fragment combinations (lists of fragment indices).\n        molsPerRow: The number of molecules to display in each row of the grid.\n        subImgSize: The size (width, height) of each molecule image in the grid.\n\n    Returns:\n        A list of PIL Image objects, each visualizing a retrosynthesis solution.\n    \"\"\"\n    all_img = []\n    for solution in solutions:\n        logger.info(f\"[RetrosynthesisSolution] Solution: {solution}\")\n        all_smiles = self.get_solution_smiles(solution)\n        logger.info(f\"[RetrosynthesisSolution] SMILES: {all_smiles}\")\n        # Convert SMILES to RDKit molecules\n        mols = [Chem.MolFromSmiles(smiles) for smiles in all_smiles]\n        # Draw molecules in a grid\n        legends = [f\"{comb}: {smiles}\" for comb, smiles in zip(solution, all_smiles, strict=False)]\n        img = Draw.MolsToGridImage(mols, molsPerRow=molsPerRow, subImgSize=subImgSize, legends=legends)\n        all_img.append(img)\n    return all_img\n</code></pre>"},{"location":"FragmentRetro/substructure-matcher/","title":"Substructure Match","text":"<p>Check if a fragment (which can contain dummy or any atoms represented by \"*\") is a strict substructure of a molecule. A strict substructure means that no additional atoms should be present in the molecule other than those explicitly defined in the fragment. Extra atoms (including hydrogen atoms) are only allowed at the sites of dummy atoms in the fragment.</p>"},{"location":"FragmentRetro/substructure-matcher/#example-use","title":"Example Use","text":"<pre><code>from fragmentretro.substructure_matcher import SubstructureMatcher\n\nfragment_smiles = \"[4*]CCN[5*]\",\nmolecule_smiles = \"CCCNC\"\n\nprint(SubstructureMatcher.is_strict_substructure(fragment_smiles, molecule_smiles))\n# should print True\n</code></pre>"},{"location":"FragmentRetro/substructure-matcher/#source-code","title":"Source Code","text":""},{"location":"FragmentRetro/substructure-matcher/#fragmentretro.substructure_matcher","title":"<code>fragmentretro.substructure_matcher</code>","text":""},{"location":"FragmentRetro/substructure-matcher/#fragmentretro.substructure_matcher.SubstructureMatcher","title":"<code>SubstructureMatcher</code>","text":"Source code in <code>src/fragmentretro/substructure_matcher.py</code> <pre><code>class SubstructureMatcher:\n    def __init__(\n        self,\n        BBs: BBsType,\n        useChirality: bool = True,\n        parallelize: bool = False,\n        num_cores: int | None = None,\n        core_factor: int = 10,\n    ):\n        \"\"\"\n        Initialize with a set of building blocks (BBs).\n\n        Args:\n            BBs: Set of building block SMILES strings.\n            useChirality: Whether to match chirality.\n            parallelize: Whether to enable parallel processing.\n            num_cores: Number of CPU cores to use for parallel processing. If None, uses all available cores.\n            core_factor: Factor to determine when to use parallel processing. If the number of BBs is greater than\n                         `num_cores * core_factor`, parallel processing will be used.\n        \"\"\"\n        self.BBs = BBs\n        self.useChirality = useChirality\n        self.parallelize = parallelize\n        # Use all available cores if not specified\n        self.num_cores = min(num_cores if num_cores is not None else cpu_count(), cpu_count())\n        self.core_factor = core_factor\n\n    @staticmethod\n    def has_dummy_neighbor(atom: Atom) -&gt; bool:\n        dummy_neighbor = False\n        for neighbor in atom.GetNeighbors():\n            if neighbor.GetSymbol() == \"*\":  # Neighbor is wildcard\n                dummy_neighbor = True\n                break\n        return dummy_neighbor\n\n    @staticmethod\n    def convert_to_smarts(fragment_smiles: str) -&gt; str:\n        \"\"\"\n        Convert a fragment SMILES string into a SMARTS string with hydrogen counts\n        explicitly specified, and convert dummy atoms into wildcards.\n\n        Args:\n            fragment_smiles: SMILES string of the fragment.\n\n        Returns:\n            SMARTS string with explicit hydrogen counts, handling dummy atoms.\n        \"\"\"\n        mol = Chem.MolFromSmiles(fragment_smiles)\n        # Add indices to atoms so that the `replace` function would\n        # not replace atoms with the same atomic number\n        for i, atom in enumerate(mol.GetAtoms()):\n            atom.SetAtomMapNum(i + 1)\n        if mol is None:\n            raise ValueError(f\"Invalid SMILES string: {fragment_smiles}\")\n        smarts = Chem.MolToSmarts(mol)\n        # Replace only specific indices\n        for atom in mol.GetAtoms():\n            atomic_num = atom.GetAtomicNum()\n            if atomic_num == 0:\n                continue\n            num_hydrogens = atom.GetTotalNumHs()\n            idx = atom.GetAtomMapNum()\n            if num_hydrogens == 0:\n                smarts = re.sub(rf\"\\[\\#{atomic_num}(@*):{idx}\\]\", rf\"[#{atomic_num}\\1&amp;H{num_hydrogens}:{idx}]\", smarts)\n            else:\n                smarts = re.sub(rf\"\\[\\#{atomic_num}:{idx}\\]\", rf\"[#{atomic_num}&amp;H{num_hydrogens}:{idx}]\", smarts)\n        # Remove indices\n        smarts = re.sub(r\":\\d+\\]\", \"]\", smarts)\n        # sub [#0] with *, which is a wildcard for any atom\n        smarts = re.sub(r\"\\[\\d*\\#0\\]\", \"*\", smarts)\n        return cast(str, smarts)\n\n    @staticmethod\n    def addH_to_wildcard_neighbors(fragment_smarts: str) -&gt; str:\n        \"\"\"\n        Adjust SMARTS by adding hydrogens to neighbors of wildcard atoms (*).\n\n        Args:\n            fragment_smarts: Fragment SMARTS string.\n\n        Returns:\n            Adjusted SMARTS string with explicit hydrogen counts for neighbors of wildcards.\n        \"\"\"\n        # TODO: make sure this works properly and see if we want to merge this with convert_to_smarts\n\n        # Convert SMARTS to molecule\n        fragment_mol = Chem.MolFromSmarts(fragment_smarts)\n        if fragment_mol is None:\n            raise ValueError(f\"Invalid SMARTS string: {fragment_smarts}\")\n\n        # Assign map indices to each atom\n        for i, atom in enumerate(fragment_mol.GetAtoms()):\n            atom.SetAtomMapNum(i + 1)\n\n        # Convert molecule back to SMARTS with indices\n        smarts_with_indices = Chem.MolToSmarts(fragment_mol)\n\n        # Sanitize mol to avoid aromatic valency problems\n        Chem.SanitizeMol(fragment_mol)\n\n        for atom in fragment_mol.GetAtoms():\n            dummy_neighbor = SubstructureMatcher.has_dummy_neighbor(atom)\n\n            if dummy_neighbor:\n                atomic_num = atom.GetAtomicNum()\n                num_hydrogens = atom.GetTotalNumHs()\n                idx = atom.GetAtomMapNum()\n\n                logger.debug(\"smarts_with_indices: %s\", smarts_with_indices)\n                logger.debug(\"updating atom idx: %s\", idx)\n                # Update SMARTS with explicit hydrogen count\n                # remove chirality information (in re group \\1) for atoms with dummy neighbors\n                smarts_with_indices = re.sub(\n                    rf\"\\[\\#{atomic_num}(@*)&amp;H{num_hydrogens}:{idx}\\]\",\n                    rf\"[#{atomic_num}&amp;H{num_hydrogens},#{atomic_num}&amp;H{num_hydrogens + 1}:{idx}]\",\n                    smarts_with_indices,\n                )\n                logger.debug(\"smarts_with_indices: %s\", smarts_with_indices)\n\n        # Remove atom map indices\n        adjusted_smarts = re.sub(r\":\\d+\\]\", \"]\", smarts_with_indices)\n        return adjusted_smarts\n\n    @staticmethod\n    def is_strict_substructure(fragment_smiles: str, molecule_smiles: str, useChirality: bool = True) -&gt; bool:\n        \"\"\"\n        Check if the fragment is a strict substructure of the molecule. No extra atoms or\n        branchings should be in the molecule other than the ones explicitly defined in the\n        fragment, except for dummy atoms.\n\n        Args:\n            fragment_smiles: SMILES string of the fragment.\n            molecule_smiles: SMILES string of the molecule.\n            useChirality: whether to match chirality\n\n        Returns:\n            True if the fragment is a strict substructure of the molecule, False otherwise.\n        \"\"\"\n        # Convert fragment SMILES to SMARTS pattern\n        # hydrogen counts are explicitly specified to strictly match the fragment\n        fragment_smarts = SubstructureMatcher.convert_to_smarts(fragment_smiles)\n        # Add hydrogen atoms to wildcard neighbors to ensure hydrogen atoms can match with wildcard atoms\n        fragment_smarts_withH = SubstructureMatcher.addH_to_wildcard_neighbors(fragment_smarts)\n\n        # Convert molecule SMILES to RDKit molecule object\n        # fragment_mol = Chem.MolFromSmarts(fragment_smarts)\n        fragment_mol_withH = Chem.MolFromSmarts(fragment_smarts_withH)\n        molecule_mol = Chem.MolFromSmiles(molecule_smiles)\n        # to make sure hydrogen atoms can match with wildcard atoms\n        molecule_mol = Chem.AddHs(molecule_mol)\n\n        if molecule_mol is None:\n            raise ValueError(f\"Invalid SMILES string: {molecule_smiles}\")\n        return cast(bool, molecule_mol.HasSubstructMatch(fragment_mol_withH, useChirality=useChirality))\n\n    def get_substructure_BBs(self, fragment: str) -&gt; BBsType:\n        \"\"\"\n        Get the set of building blocks (BBs) that the fragment matches.\n\n        Args:\n            fragment: SMILES string of the fragment.\n\n        Returns:\n            Set of building block SMILES strings that the fragment matches.\n        \"\"\"\n        logger.info(f\"[SubstructureMatcher] Matching fragment {fragment} to building blocks\")\n        if self.parallelize and len(self.BBs) &gt;= self.num_cores * self.core_factor:\n            logger.info(f\"[SubstructureMatcher] Using {self.num_cores} cores for parallel processing\")\n            with Pool(processes=self.num_cores) as pool:\n                results = pool.starmap(\n                    self.is_strict_substructure, [(fragment, bb, self.useChirality) for bb in self.BBs]\n                )\n                strict_substructure_BBs = set(bb for bb, result in zip(self.BBs, results, strict=False) if result)\n\n        else:\n            # Fallback to single-threaded execution\n            strict_substructure_BBs = set(\n                bb for bb in self.BBs if self.is_strict_substructure(fragment, bb, self.useChirality)\n            )\n        logger.info(f\"[SubstructureMatcher] Found {len(strict_substructure_BBs)} matching building\")\n        return strict_substructure_BBs\n</code></pre>"},{"location":"FragmentRetro/substructure-matcher/#fragmentretro.substructure_matcher.SubstructureMatcher.__init__","title":"<code>__init__(BBs, useChirality=True, parallelize=False, num_cores=None, core_factor=10)</code>","text":"<p>Initialize with a set of building blocks (BBs).</p> <p>Parameters:</p> Name Type Description Default <code>BBs</code> <code>BBsType</code> <p>Set of building block SMILES strings.</p> required <code>useChirality</code> <code>bool</code> <p>Whether to match chirality.</p> <code>True</code> <code>parallelize</code> <code>bool</code> <p>Whether to enable parallel processing.</p> <code>False</code> <code>num_cores</code> <code>int | None</code> <p>Number of CPU cores to use for parallel processing. If None, uses all available cores.</p> <code>None</code> <code>core_factor</code> <code>int</code> <p>Factor to determine when to use parallel processing. If the number of BBs is greater than          <code>num_cores * core_factor</code>, parallel processing will be used.</p> <code>10</code> Source code in <code>src/fragmentretro/substructure_matcher.py</code> <pre><code>def __init__(\n    self,\n    BBs: BBsType,\n    useChirality: bool = True,\n    parallelize: bool = False,\n    num_cores: int | None = None,\n    core_factor: int = 10,\n):\n    \"\"\"\n    Initialize with a set of building blocks (BBs).\n\n    Args:\n        BBs: Set of building block SMILES strings.\n        useChirality: Whether to match chirality.\n        parallelize: Whether to enable parallel processing.\n        num_cores: Number of CPU cores to use for parallel processing. If None, uses all available cores.\n        core_factor: Factor to determine when to use parallel processing. If the number of BBs is greater than\n                     `num_cores * core_factor`, parallel processing will be used.\n    \"\"\"\n    self.BBs = BBs\n    self.useChirality = useChirality\n    self.parallelize = parallelize\n    # Use all available cores if not specified\n    self.num_cores = min(num_cores if num_cores is not None else cpu_count(), cpu_count())\n    self.core_factor = core_factor\n</code></pre>"},{"location":"FragmentRetro/substructure-matcher/#fragmentretro.substructure_matcher.SubstructureMatcher.convert_to_smarts","title":"<code>convert_to_smarts(fragment_smiles)</code>  <code>staticmethod</code>","text":"<p>Convert a fragment SMILES string into a SMARTS string with hydrogen counts explicitly specified, and convert dummy atoms into wildcards.</p> <p>Parameters:</p> Name Type Description Default <code>fragment_smiles</code> <code>str</code> <p>SMILES string of the fragment.</p> required <p>Returns:</p> Type Description <code>str</code> <p>SMARTS string with explicit hydrogen counts, handling dummy atoms.</p> Source code in <code>src/fragmentretro/substructure_matcher.py</code> <pre><code>@staticmethod\ndef convert_to_smarts(fragment_smiles: str) -&gt; str:\n    \"\"\"\n    Convert a fragment SMILES string into a SMARTS string with hydrogen counts\n    explicitly specified, and convert dummy atoms into wildcards.\n\n    Args:\n        fragment_smiles: SMILES string of the fragment.\n\n    Returns:\n        SMARTS string with explicit hydrogen counts, handling dummy atoms.\n    \"\"\"\n    mol = Chem.MolFromSmiles(fragment_smiles)\n    # Add indices to atoms so that the `replace` function would\n    # not replace atoms with the same atomic number\n    for i, atom in enumerate(mol.GetAtoms()):\n        atom.SetAtomMapNum(i + 1)\n    if mol is None:\n        raise ValueError(f\"Invalid SMILES string: {fragment_smiles}\")\n    smarts = Chem.MolToSmarts(mol)\n    # Replace only specific indices\n    for atom in mol.GetAtoms():\n        atomic_num = atom.GetAtomicNum()\n        if atomic_num == 0:\n            continue\n        num_hydrogens = atom.GetTotalNumHs()\n        idx = atom.GetAtomMapNum()\n        if num_hydrogens == 0:\n            smarts = re.sub(rf\"\\[\\#{atomic_num}(@*):{idx}\\]\", rf\"[#{atomic_num}\\1&amp;H{num_hydrogens}:{idx}]\", smarts)\n        else:\n            smarts = re.sub(rf\"\\[\\#{atomic_num}:{idx}\\]\", rf\"[#{atomic_num}&amp;H{num_hydrogens}:{idx}]\", smarts)\n    # Remove indices\n    smarts = re.sub(r\":\\d+\\]\", \"]\", smarts)\n    # sub [#0] with *, which is a wildcard for any atom\n    smarts = re.sub(r\"\\[\\d*\\#0\\]\", \"*\", smarts)\n    return cast(str, smarts)\n</code></pre>"},{"location":"FragmentRetro/substructure-matcher/#fragmentretro.substructure_matcher.SubstructureMatcher.addH_to_wildcard_neighbors","title":"<code>addH_to_wildcard_neighbors(fragment_smarts)</code>  <code>staticmethod</code>","text":"<p>Adjust SMARTS by adding hydrogens to neighbors of wildcard atoms (*).</p> <p>Parameters:</p> Name Type Description Default <code>fragment_smarts</code> <code>str</code> <p>Fragment SMARTS string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Adjusted SMARTS string with explicit hydrogen counts for neighbors of wildcards.</p> Source code in <code>src/fragmentretro/substructure_matcher.py</code> <pre><code>@staticmethod\ndef addH_to_wildcard_neighbors(fragment_smarts: str) -&gt; str:\n    \"\"\"\n    Adjust SMARTS by adding hydrogens to neighbors of wildcard atoms (*).\n\n    Args:\n        fragment_smarts: Fragment SMARTS string.\n\n    Returns:\n        Adjusted SMARTS string with explicit hydrogen counts for neighbors of wildcards.\n    \"\"\"\n    # TODO: make sure this works properly and see if we want to merge this with convert_to_smarts\n\n    # Convert SMARTS to molecule\n    fragment_mol = Chem.MolFromSmarts(fragment_smarts)\n    if fragment_mol is None:\n        raise ValueError(f\"Invalid SMARTS string: {fragment_smarts}\")\n\n    # Assign map indices to each atom\n    for i, atom in enumerate(fragment_mol.GetAtoms()):\n        atom.SetAtomMapNum(i + 1)\n\n    # Convert molecule back to SMARTS with indices\n    smarts_with_indices = Chem.MolToSmarts(fragment_mol)\n\n    # Sanitize mol to avoid aromatic valency problems\n    Chem.SanitizeMol(fragment_mol)\n\n    for atom in fragment_mol.GetAtoms():\n        dummy_neighbor = SubstructureMatcher.has_dummy_neighbor(atom)\n\n        if dummy_neighbor:\n            atomic_num = atom.GetAtomicNum()\n            num_hydrogens = atom.GetTotalNumHs()\n            idx = atom.GetAtomMapNum()\n\n            logger.debug(\"smarts_with_indices: %s\", smarts_with_indices)\n            logger.debug(\"updating atom idx: %s\", idx)\n            # Update SMARTS with explicit hydrogen count\n            # remove chirality information (in re group \\1) for atoms with dummy neighbors\n            smarts_with_indices = re.sub(\n                rf\"\\[\\#{atomic_num}(@*)&amp;H{num_hydrogens}:{idx}\\]\",\n                rf\"[#{atomic_num}&amp;H{num_hydrogens},#{atomic_num}&amp;H{num_hydrogens + 1}:{idx}]\",\n                smarts_with_indices,\n            )\n            logger.debug(\"smarts_with_indices: %s\", smarts_with_indices)\n\n    # Remove atom map indices\n    adjusted_smarts = re.sub(r\":\\d+\\]\", \"]\", smarts_with_indices)\n    return adjusted_smarts\n</code></pre>"},{"location":"FragmentRetro/substructure-matcher/#fragmentretro.substructure_matcher.SubstructureMatcher.is_strict_substructure","title":"<code>is_strict_substructure(fragment_smiles, molecule_smiles, useChirality=True)</code>  <code>staticmethod</code>","text":"<p>Check if the fragment is a strict substructure of the molecule. No extra atoms or branchings should be in the molecule other than the ones explicitly defined in the fragment, except for dummy atoms.</p> <p>Parameters:</p> Name Type Description Default <code>fragment_smiles</code> <code>str</code> <p>SMILES string of the fragment.</p> required <code>molecule_smiles</code> <code>str</code> <p>SMILES string of the molecule.</p> required <code>useChirality</code> <code>bool</code> <p>whether to match chirality</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the fragment is a strict substructure of the molecule, False otherwise.</p> Source code in <code>src/fragmentretro/substructure_matcher.py</code> <pre><code>@staticmethod\ndef is_strict_substructure(fragment_smiles: str, molecule_smiles: str, useChirality: bool = True) -&gt; bool:\n    \"\"\"\n    Check if the fragment is a strict substructure of the molecule. No extra atoms or\n    branchings should be in the molecule other than the ones explicitly defined in the\n    fragment, except for dummy atoms.\n\n    Args:\n        fragment_smiles: SMILES string of the fragment.\n        molecule_smiles: SMILES string of the molecule.\n        useChirality: whether to match chirality\n\n    Returns:\n        True if the fragment is a strict substructure of the molecule, False otherwise.\n    \"\"\"\n    # Convert fragment SMILES to SMARTS pattern\n    # hydrogen counts are explicitly specified to strictly match the fragment\n    fragment_smarts = SubstructureMatcher.convert_to_smarts(fragment_smiles)\n    # Add hydrogen atoms to wildcard neighbors to ensure hydrogen atoms can match with wildcard atoms\n    fragment_smarts_withH = SubstructureMatcher.addH_to_wildcard_neighbors(fragment_smarts)\n\n    # Convert molecule SMILES to RDKit molecule object\n    # fragment_mol = Chem.MolFromSmarts(fragment_smarts)\n    fragment_mol_withH = Chem.MolFromSmarts(fragment_smarts_withH)\n    molecule_mol = Chem.MolFromSmiles(molecule_smiles)\n    # to make sure hydrogen atoms can match with wildcard atoms\n    molecule_mol = Chem.AddHs(molecule_mol)\n\n    if molecule_mol is None:\n        raise ValueError(f\"Invalid SMILES string: {molecule_smiles}\")\n    return cast(bool, molecule_mol.HasSubstructMatch(fragment_mol_withH, useChirality=useChirality))\n</code></pre>"},{"location":"FragmentRetro/substructure-matcher/#fragmentretro.substructure_matcher.SubstructureMatcher.get_substructure_BBs","title":"<code>get_substructure_BBs(fragment)</code>","text":"<p>Get the set of building blocks (BBs) that the fragment matches.</p> <p>Parameters:</p> Name Type Description Default <code>fragment</code> <code>str</code> <p>SMILES string of the fragment.</p> required <p>Returns:</p> Type Description <code>BBsType</code> <p>Set of building block SMILES strings that the fragment matches.</p> Source code in <code>src/fragmentretro/substructure_matcher.py</code> <pre><code>def get_substructure_BBs(self, fragment: str) -&gt; BBsType:\n    \"\"\"\n    Get the set of building blocks (BBs) that the fragment matches.\n\n    Args:\n        fragment: SMILES string of the fragment.\n\n    Returns:\n        Set of building block SMILES strings that the fragment matches.\n    \"\"\"\n    logger.info(f\"[SubstructureMatcher] Matching fragment {fragment} to building blocks\")\n    if self.parallelize and len(self.BBs) &gt;= self.num_cores * self.core_factor:\n        logger.info(f\"[SubstructureMatcher] Using {self.num_cores} cores for parallel processing\")\n        with Pool(processes=self.num_cores) as pool:\n            results = pool.starmap(\n                self.is_strict_substructure, [(fragment, bb, self.useChirality) for bb in self.BBs]\n            )\n            strict_substructure_BBs = set(bb for bb, result in zip(self.BBs, results, strict=False) if result)\n\n    else:\n        # Fallback to single-threaded execution\n        strict_substructure_BBs = set(\n            bb for bb in self.BBs if self.is_strict_substructure(fragment, bb, self.useChirality)\n        )\n    logger.info(f\"[SubstructureMatcher] Found {len(strict_substructure_BBs)} matching building\")\n    return strict_substructure_BBs\n</code></pre>"},{"location":"FragmentRetro/typing/","title":"Type Definitions","text":"<p><code>fragmentretro.typing</code> is a good place to store your type definitions to make code clean and pass mypy tests.</p>"},{"location":"FragmentRetro/typing/#example-usage","title":"Example Usage","text":"<pre><code>from fragmentretro.typing import BondType\n\ndef _find_fragmentation_bonds(mol: Mol) -&gt; list[BondType]:\n    return list(FindBRICSBonds(mol))\n</code></pre> <p>where <code>BondType</code> is defined in <code>fragmentretro.typing</code> as:</p> <pre><code>type BondType = tuple[tuple[int, int], tuple[str, str]]\n</code></pre>"},{"location":"FragmentRetro/typing/#source-code","title":"Source Code","text":""},{"location":"FragmentRetro/typing/#fragmentretro.typing","title":"<code>fragmentretro.typing</code>","text":"<p>Type definitions for FragmentRetro package.</p>"},{"location":"FragmentRetro/typing/#fragmentretro.typing.MolProperties","title":"<code>MolProperties</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type definition for molecular properties.</p> Source code in <code>src/fragmentretro/typing.py</code> <pre><code>class MolProperties(TypedDict, total=True):\n    \"\"\"Type definition for molecular properties.\"\"\"\n\n    cano_smiles: str\n    num_heavy_atoms: int\n    num_rings: int\n    pfp: list[int]  # Pattern Fingerprint\n</code></pre>"},{"location":"FragmentRetro/utils/filter-compound/","title":"Compound Filtering","text":"<p>This module provides functions for filtering compounds based on precomputed molecular properties (number of heavy atoms, number of rings, and pattern fingerprints).</p>"},{"location":"FragmentRetro/utils/filter-compound/#example-use","title":"Example Use","text":"<p>The <code>precompute_properties</code> function computes properties for a large set of compounds and saves them to a JSON file.  The example below shows how to use it with a subset of the <code>n1-stock.txt</code> file.</p> <pre><code>from pathlib import Path\nfrom fragmentretro.utils.filter_compound import precompute_properties\n\nDATA_PATH = Path(__file__).parent.parent / \"data\"\nPAROUTES_PATH = DATA_PATH / \"paroutes\"\nPRECOMPUTE_PATH = DATA_PATH / \"precompute\"\nMOL_PROPERTIES_PATH = PRECOMPUTE_PATH / \"n1_stock_properties_subset.json\"\n\n# Create the directory if it doesn't exist\nPRECOMPUTE_PATH.mkdir(parents=True, exist_ok=True)\n\nwith open(PAROUTES_PATH / \"n1-stock.txt\") as f:\n    n1_stock = [line.strip() for line in f]\nn1_stock_subset = n1_stock[:500]\nprecompute_properties(n1_stock_subset, MOL_PROPERTIES_PATH, fpSize=2048)\n</code></pre> <p>The <code>CompoundFilter</code> class is used to initialize a filter, and the <code>get_filtered_BBs</code> method retrieves the screened building blocks. The following example demonstrates filtering using a specific fragment SMILES string.</p> <pre><code>from fragmentretro.utils.filter_compound import CompoundFilter\nfrom fragmentretro.utils.helpers import replace_dummy_atoms_regex\n\nfragment_smiles_list = [\"[5*]N1CCC[C@@]1([13*])C\", \"[4*]CCN[5*]\", \"[4*]C[8*]\", \"[*]C[*]\", \"[3*]O[3*]\"]\nfragment_smiles = fragment_smiles_list[1]\n\ncompound_filter = CompoundFilter(MOL_PROPERTIES_PATH, fpSize=2048)\nfiltered_indices, filtered_BBs = compound_filter.get_filtered_BBs(fragment_smiles)\n</code></pre>"},{"location":"FragmentRetro/utils/filter-compound/#source-code","title":"Source Code","text":""},{"location":"FragmentRetro/utils/filter-compound/#fragmentretro.utils.filter_compound","title":"<code>fragmentretro.utils.filter_compound</code>","text":""},{"location":"FragmentRetro/utils/filter-compound/#fragmentretro.utils.filter_compound.CompoundFilter","title":"<code>CompoundFilter</code>","text":"<p>A class for filtering compounds based on precomputed molecular properties.</p> Source code in <code>src/fragmentretro/utils/filter_compound.py</code> <pre><code>class CompoundFilter:\n    \"\"\"A class for filtering compounds based on precomputed molecular properties.\"\"\"\n\n    def __init__(self, mol_properties_path: Path, fpSize: int = 2048):\n        \"\"\"\n        Initializes the CompoundFilter with molecular properties loaded from a JSON file.\n\n        Args:\n            mol_properties_path: Path to the JSON file containing molecular properties.\n        \"\"\"\n        self.mol_properties_path = mol_properties_path\n        self.cano_smiles_list: list[str] = []\n        self.num_heavy_atoms_list: list[int] = []\n        self.num_rings_list: list[int] = []\n        self.pfp_len_list: list[int] = []\n        self.pfp_list: list[list[int]] = []\n        self.fpSize = fpSize\n\n        self._load_mol_properties()\n        self._create_numpy_arrays()\n\n    def _load_mol_properties(self) -&gt; None:\n        \"\"\"Loads molecular properties from the JSON file.\"\"\"\n\n        logger.info(\"[CompoundFilter] Loading mol properties\")\n        with open(self.mol_properties_path) as f:\n            mol_properties_list = json.load(f)\n\n        self.len_BBs = len(mol_properties_list)\n        self.cano_smiles_list = [props[\"cano_smiles\"] for props in mol_properties_list]\n        self.num_heavy_atoms_list = [props[\"num_heavy_atoms\"] for props in mol_properties_list]\n        self.num_rings_list = [props[\"num_rings\"] for props in mol_properties_list]\n        self.pfp_len_list = [len(props[\"pfp\"]) for props in mol_properties_list]\n        self.pfp_list = [props[\"pfp\"] for props in mol_properties_list]\n        logger.info(\"[CompoundFilter] Finished loading mol properties\")\n\n    def _create_numpy_arrays(self) -&gt; None:\n        \"\"\"Creates NumPy arrays for faster filtering.\"\"\"\n        self.num_heavy_atoms_array = np.array(self.num_heavy_atoms_list)\n        self.num_rings_array = np.array(self.num_rings_list)\n        self.pfp_len_array = np.array(self.pfp_len_list)\n\n        # Create a boolean NumPy array for PFP bits\n        self.pfp_bit_array = np.zeros((len(self.pfp_list), self.fpSize), dtype=bool)\n        for i, pfp in enumerate(self.pfp_list):\n            self.pfp_bit_array[i, pfp] = True\n\n    def filter_compounds(self, smiles: str, prefiltered_indices: FilterIndicesType | None = None) -&gt; FilterIndicesType:\n        \"\"\"Filters compounds based on a query SMILES string and prefiltered indices.\n        Note that dummy atoms have to be replaced by hydrogen atoms so that we can get\n        the minimal format for pattern fingerprint processing.\n\n        Args:\n            smiles: The query SMILES string.\n            prefiltered_indices: A list of prefiltered indices.\n\n        Returns:\n            A list of indices of the compounds that pass the filter.\n        \"\"\"\n        no_dummy_smiles = replace_dummy_atoms_regex(smiles)\n        try:\n            mol_properties = get_mol_properties(no_dummy_smiles, fpSize=self.fpSize)\n        except ValueError as e:\n            print(f\"Invalid SMILES: {e}\")\n            return []\n\n        logger.info(f\"[CompoundFilter] Filtering BBs for {no_dummy_smiles} ( {smiles} )\")\n\n        num_heavy_atoms = mol_properties[\"num_heavy_atoms\"]\n        num_rings = mol_properties[\"num_rings\"]\n        pfp = mol_properties[\"pfp\"]\n        pfp_len = len(pfp)\n\n        query_pfp_bit_array = np.zeros(self.fpSize, dtype=bool)\n        query_pfp_bit_array[pfp] = True\n\n        # Filtering based on molecular properties\n        indices_array = np.where(\n            (self.num_heavy_atoms_array &gt;= num_heavy_atoms)\n            &amp; (self.num_rings_array &gt;= num_rings)\n            &amp; (self.pfp_len_array &gt;= pfp_len)\n        )[0]\n        if prefiltered_indices is not None:\n            indices_array = np.intersect1d(indices_array, prefiltered_indices)\n\n        # check pfp of query is a subset of pfp of filtered compounds\n        if indices_array.size == 0:\n            filtered_indices = []\n        else:\n            filtered_indices = indices_array[\n                np.all(self.pfp_bit_array[indices_array][:, query_pfp_bit_array], axis=1)\n            ].tolist()\n\n        if prefiltered_indices is None:\n            logger.info(f\"[CompoundFilter] Originally {self.len_BBs} BBs, filtered down to {len(filtered_indices)}\")\n        else:\n            logger.info(\n                f\"[CompoundFilter] Originally {len(prefiltered_indices)} BBs, filtered down to {len(filtered_indices)}\"\n            )\n\n        return filtered_indices\n\n    def get_filtered_BBs(\n        self, smiles: str, prefiltered_indices: FilterIndicesType | None = None\n    ) -&gt; tuple[FilterIndicesType, BBsType]:\n        \"\"\"Filters building blocks based on a query SMILES string and prefiltered indices.\n\n        This method filters the building blocks based on the properties\n        of the provided SMILES string and a list of prefiltered indices.\n        It uses the `filter_compounds` method to get a list of indices\n        that pass the filter, and then returns a set of the corresponding\n        canonical SMILES strings.\n\n        Args:\n            smiles: The query SMILES string.\n            prefiltered_indices: A list of prefiltered indices.\n\n        Returns:\n            tuple[list[int], BBsType]: A tuple containing a list of indices\n            of the compounds that pass the filter and a set of canonical\n            SMILES strings of the building blocks that pass the filter.\n        \"\"\"\n        filtered_indices = self.filter_compounds(smiles, prefiltered_indices)\n        return filtered_indices, set(self.cano_smiles_list[i] for i in filtered_indices)\n</code></pre>"},{"location":"FragmentRetro/utils/filter-compound/#fragmentretro.utils.filter_compound.CompoundFilter.__init__","title":"<code>__init__(mol_properties_path, fpSize=2048)</code>","text":"<p>Initializes the CompoundFilter with molecular properties loaded from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>mol_properties_path</code> <code>Path</code> <p>Path to the JSON file containing molecular properties.</p> required Source code in <code>src/fragmentretro/utils/filter_compound.py</code> <pre><code>def __init__(self, mol_properties_path: Path, fpSize: int = 2048):\n    \"\"\"\n    Initializes the CompoundFilter with molecular properties loaded from a JSON file.\n\n    Args:\n        mol_properties_path: Path to the JSON file containing molecular properties.\n    \"\"\"\n    self.mol_properties_path = mol_properties_path\n    self.cano_smiles_list: list[str] = []\n    self.num_heavy_atoms_list: list[int] = []\n    self.num_rings_list: list[int] = []\n    self.pfp_len_list: list[int] = []\n    self.pfp_list: list[list[int]] = []\n    self.fpSize = fpSize\n\n    self._load_mol_properties()\n    self._create_numpy_arrays()\n</code></pre>"},{"location":"FragmentRetro/utils/filter-compound/#fragmentretro.utils.filter_compound.CompoundFilter.filter_compounds","title":"<code>filter_compounds(smiles, prefiltered_indices=None)</code>","text":"<p>Filters compounds based on a query SMILES string and prefiltered indices. Note that dummy atoms have to be replaced by hydrogen atoms so that we can get the minimal format for pattern fingerprint processing.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>The query SMILES string.</p> required <code>prefiltered_indices</code> <code>FilterIndicesType | None</code> <p>A list of prefiltered indices.</p> <code>None</code> <p>Returns:</p> Type Description <code>FilterIndicesType</code> <p>A list of indices of the compounds that pass the filter.</p> Source code in <code>src/fragmentretro/utils/filter_compound.py</code> <pre><code>def filter_compounds(self, smiles: str, prefiltered_indices: FilterIndicesType | None = None) -&gt; FilterIndicesType:\n    \"\"\"Filters compounds based on a query SMILES string and prefiltered indices.\n    Note that dummy atoms have to be replaced by hydrogen atoms so that we can get\n    the minimal format for pattern fingerprint processing.\n\n    Args:\n        smiles: The query SMILES string.\n        prefiltered_indices: A list of prefiltered indices.\n\n    Returns:\n        A list of indices of the compounds that pass the filter.\n    \"\"\"\n    no_dummy_smiles = replace_dummy_atoms_regex(smiles)\n    try:\n        mol_properties = get_mol_properties(no_dummy_smiles, fpSize=self.fpSize)\n    except ValueError as e:\n        print(f\"Invalid SMILES: {e}\")\n        return []\n\n    logger.info(f\"[CompoundFilter] Filtering BBs for {no_dummy_smiles} ( {smiles} )\")\n\n    num_heavy_atoms = mol_properties[\"num_heavy_atoms\"]\n    num_rings = mol_properties[\"num_rings\"]\n    pfp = mol_properties[\"pfp\"]\n    pfp_len = len(pfp)\n\n    query_pfp_bit_array = np.zeros(self.fpSize, dtype=bool)\n    query_pfp_bit_array[pfp] = True\n\n    # Filtering based on molecular properties\n    indices_array = np.where(\n        (self.num_heavy_atoms_array &gt;= num_heavy_atoms)\n        &amp; (self.num_rings_array &gt;= num_rings)\n        &amp; (self.pfp_len_array &gt;= pfp_len)\n    )[0]\n    if prefiltered_indices is not None:\n        indices_array = np.intersect1d(indices_array, prefiltered_indices)\n\n    # check pfp of query is a subset of pfp of filtered compounds\n    if indices_array.size == 0:\n        filtered_indices = []\n    else:\n        filtered_indices = indices_array[\n            np.all(self.pfp_bit_array[indices_array][:, query_pfp_bit_array], axis=1)\n        ].tolist()\n\n    if prefiltered_indices is None:\n        logger.info(f\"[CompoundFilter] Originally {self.len_BBs} BBs, filtered down to {len(filtered_indices)}\")\n    else:\n        logger.info(\n            f\"[CompoundFilter] Originally {len(prefiltered_indices)} BBs, filtered down to {len(filtered_indices)}\"\n        )\n\n    return filtered_indices\n</code></pre>"},{"location":"FragmentRetro/utils/filter-compound/#fragmentretro.utils.filter_compound.CompoundFilter.get_filtered_BBs","title":"<code>get_filtered_BBs(smiles, prefiltered_indices=None)</code>","text":"<p>Filters building blocks based on a query SMILES string and prefiltered indices.</p> <p>This method filters the building blocks based on the properties of the provided SMILES string and a list of prefiltered indices. It uses the <code>filter_compounds</code> method to get a list of indices that pass the filter, and then returns a set of the corresponding canonical SMILES strings.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>The query SMILES string.</p> required <code>prefiltered_indices</code> <code>FilterIndicesType | None</code> <p>A list of prefiltered indices.</p> <code>None</code> <p>Returns:</p> Type Description <code>FilterIndicesType</code> <p>tuple[list[int], BBsType]: A tuple containing a list of indices</p> <code>BBsType</code> <p>of the compounds that pass the filter and a set of canonical</p> <code>tuple[FilterIndicesType, BBsType]</code> <p>SMILES strings of the building blocks that pass the filter.</p> Source code in <code>src/fragmentretro/utils/filter_compound.py</code> <pre><code>def get_filtered_BBs(\n    self, smiles: str, prefiltered_indices: FilterIndicesType | None = None\n) -&gt; tuple[FilterIndicesType, BBsType]:\n    \"\"\"Filters building blocks based on a query SMILES string and prefiltered indices.\n\n    This method filters the building blocks based on the properties\n    of the provided SMILES string and a list of prefiltered indices.\n    It uses the `filter_compounds` method to get a list of indices\n    that pass the filter, and then returns a set of the corresponding\n    canonical SMILES strings.\n\n    Args:\n        smiles: The query SMILES string.\n        prefiltered_indices: A list of prefiltered indices.\n\n    Returns:\n        tuple[list[int], BBsType]: A tuple containing a list of indices\n        of the compounds that pass the filter and a set of canonical\n        SMILES strings of the building blocks that pass the filter.\n    \"\"\"\n    filtered_indices = self.filter_compounds(smiles, prefiltered_indices)\n    return filtered_indices, set(self.cano_smiles_list[i] for i in filtered_indices)\n</code></pre>"},{"location":"FragmentRetro/utils/filter-compound/#fragmentretro.utils.filter_compound.get_mol_properties","title":"<code>get_mol_properties(smiles, fpSize=2048)</code>","text":"<p>Given a SMILES string, returns a dictionary containing molecular properties.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>The SMILES string.</p> required <p>Returns:</p> Type Description <code>MolProperties</code> <p>A dictionary containing the following keys: - 'num_heavy_atoms': Number of heavy atoms - 'num_rings': Number of rings - 'pfp': Pattern fingerprint bits</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the SMILES string is invalid and cannot be converted to an RDKit molecule.</p> Source code in <code>src/fragmentretro/utils/filter_compound.py</code> <pre><code>def get_mol_properties(smiles: str, fpSize: int = 2048) -&gt; MolProperties:\n    \"\"\"Given a SMILES string, returns a dictionary containing molecular properties.\n\n    Args:\n        smiles: The SMILES string.\n\n    Returns:\n        A dictionary containing the following keys:\n            - 'num_heavy_atoms': Number of heavy atoms\n            - 'num_rings': Number of rings\n            - 'pfp': Pattern fingerprint bits\n\n    Raises:\n        ValueError: If the SMILES string is invalid and cannot be converted\n            to an RDKit molecule.\n    \"\"\"\n    if \"*\" in smiles:\n        logger.error(f\"Invalid smiles string: {smiles}, contains dummy atom '*' during get_mol_properties\")\n        raise ValueError(f\"Invalid smiles string: {smiles}, contains dummy atom '*'\")\n\n    cano_smiles = canonicalize_smiles(smiles)\n    mol = Chem.MolFromSmiles(cano_smiles)\n    # solve C++ signature problems?\n    mol.UpdatePropertyCache()\n    Chem.GetSymmSSSR(mol)\n\n    pfp = list(Chem.rdmolops.PatternFingerprint(mol, fpSize=fpSize).GetOnBits())\n\n    return {\n        \"cano_smiles\": cano_smiles,\n        \"num_heavy_atoms\": mol.GetNumHeavyAtoms(),\n        \"num_rings\": rdMolDescriptors.CalcNumRings(mol),\n        \"pfp\": pfp,\n    }\n</code></pre>"},{"location":"FragmentRetro/utils/filter-compound/#fragmentretro.utils.filter_compound.precompute_properties","title":"<code>precompute_properties(smiles_list, output_path, fpSize=2048)</code>","text":"<p>Calculates molecular properties for a list of SMILES strings and saves them to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>smiles_list</code> <code>list[str]</code> <p>A list of SMILES strings.</p> required <code>output_path</code> <code>Path</code> <p>The path to the output JSON file.</p> required Source code in <code>src/fragmentretro/utils/filter_compound.py</code> <pre><code>def precompute_properties(smiles_list: list[str], output_path: Path, fpSize: int = 2048) -&gt; None:\n    \"\"\"Calculates molecular properties for a list of SMILES strings and saves them to a JSON file.\n\n    Args:\n        smiles_list: A list of SMILES strings.\n        output_path: The path to the output JSON file.\n    \"\"\"\n    results = []\n    for smiles in tqdm(smiles_list, desc=\"Precomputing molecular properties\"):\n        try:\n            mol_properties = get_mol_properties(smiles, fpSize=fpSize)\n            results.append(mol_properties)\n        except ValueError as e:\n            logger.error(f\"Error processing SMILES '{smiles}': {e} during precompute_properties\")\n            continue\n\n    with open(output_path, \"w\") as f:\n        json.dump(results, f, indent=4)\n</code></pre>"},{"location":"FragmentRetro/utils/helper/","title":"Helper Functions","text":"<p>This module provides helper functions for working with SMILES strings.</p>"},{"location":"FragmentRetro/utils/helper/#example-use","title":"Example Use","text":"<p><code>canonicalize_smiles</code> is for canonicalizing SMILES strings.</p> <pre><code>from fragmentretro.utils.helpers import canonicalize_smiles\n\nsmiles = 'C[C@@H](O)C(=O)O'\ncanonical_smiles = canonicalize_smiles(smiles)\nprint(f\"Original SMILES: {smiles}\")\nprint(f\"Canonical SMILES: {canonical_smiles}\")\n</code></pre> <p><code>replace_dummy_atoms_regex</code> is for replacing dummy atoms with hydrogen atoms for pattern fingerprint screening. See how it's used in the <code>filter_compounds</code> function in the <code>CompoundFilter</code> class.</p> <pre><code>from fragmentretro.utils.helpers import replace_dummy_atoms_regex\n\nsmiles_with_dummy = '[5*]N1CCC[C@@]1([13*])C'\nsmiles_without_dummy = replace_dummy_atoms_regex(smiles_with_dummy)\nprint(f\"SMILES with dummy atoms: {smiles_with_dummy}\")\nprint(f\"SMILES without dummy atoms: {smiles_without_dummy}\")\n</code></pre> <p><code>remove_indices_before_dummy</code> is for removing indices before dummy atoms. This is to record processed fragment SMILES strings in the most general format. See how it's used in the <code>Retrosythesis</code> class as well.</p> <pre><code>from fragmentretro.utils.helpers import remove_indices_before_dummy\n\nsmiles_with_indices = '[5*]N1CCC[C@@]1([13*])C'\nsmiles_without_indices = remove_indices_before_dummy(smiles_with_indices)\nprint(f\"SMILES with indices: {smiles_with_indices}\")\nprint(f\"SMILES without indices: {smiles_without_indices}\")\n</code></pre>"},{"location":"FragmentRetro/utils/helper/#source-code","title":"Source Code","text":""},{"location":"FragmentRetro/utils/helper/#fragmentretro.utils.helpers","title":"<code>fragmentretro.utils.helpers</code>","text":""},{"location":"FragmentRetro/utils/helper/#fragmentretro.utils.helpers.canonicalize_smiles","title":"<code>canonicalize_smiles(smiles)</code>","text":"<p>Canonicalizes a SMILES string using RDKit.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>The SMILES string to canonicalize.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The canonicalized SMILES string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the SMILES string cannot be parsed by RDKit.</p> Source code in <code>src/fragmentretro/utils/helpers.py</code> <pre><code>def canonicalize_smiles(smiles: str) -&gt; str:\n    \"\"\"Canonicalizes a SMILES string using RDKit.\n\n    Args:\n        smiles: The SMILES string to canonicalize.\n\n    Returns:\n        The canonicalized SMILES string.\n\n    Raises:\n        ValueError: If the SMILES string cannot be parsed by RDKit.\n    \"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        raise ValueError(f\"Failed to parse SMILES: {smiles}\")\n    return cast(str, Chem.MolToSmiles(mol))\n</code></pre>"},{"location":"FragmentRetro/utils/helper/#fragmentretro.utils.helpers.count_heavy_atoms","title":"<code>count_heavy_atoms(smiles)</code>","text":"<p>Counts the number of heavy atoms in a SMILES string.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>The SMILES string representing the chemical structure.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of heavy atoms in the molecule.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the SMILES string is invalid and cannot be converted to an RDKit molecule.</p> Source code in <code>src/fragmentretro/utils/helpers.py</code> <pre><code>def count_heavy_atoms(smiles: str) -&gt; int:\n    \"\"\"Counts the number of heavy atoms in a SMILES string.\n\n    Args:\n        smiles: The SMILES string representing the chemical structure.\n\n    Returns:\n        The number of heavy atoms in the molecule.\n\n    Raises:\n        ValueError: If the SMILES string is invalid and cannot be converted\n            to an RDKit molecule.\n    \"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        raise ValueError(f\"Invalid SMILES string: {smiles}\")\n    return cast(int, mol.GetNumHeavyAtoms())\n</code></pre>"},{"location":"FragmentRetro/utils/helper/#fragmentretro.utils.helpers.sort_by_heavy_atoms","title":"<code>sort_by_heavy_atoms(smiles_list)</code>","text":"<p>Sorts a list of SMILES strings by the number of heavy atoms.</p> <p>The sorting is done in ascending order, i.e., the molecule with the fewest heavy atoms will come first.</p> <p>Parameters:</p> Name Type Description Default <code>smiles_list</code> <code>list[str]</code> <p>The list of SMILES strings to be sorted.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>The sorted list of SMILES strings.</p> Source code in <code>src/fragmentretro/utils/helpers.py</code> <pre><code>def sort_by_heavy_atoms(smiles_list: list[str]) -&gt; list[str]:\n    \"\"\"Sorts a list of SMILES strings by the number of heavy atoms.\n\n    The sorting is done in ascending order, i.e., the molecule with the fewest\n    heavy atoms will come first.\n\n    Args:\n        smiles_list: The list of SMILES strings to be sorted.\n\n    Returns:\n        The sorted list of SMILES strings.\n    \"\"\"\n    return sorted(smiles_list, key=count_heavy_atoms)\n</code></pre>"},{"location":"FragmentRetro/utils/helper/#fragmentretro.utils.helpers.replace_dummy_atoms_regex","title":"<code>replace_dummy_atoms_regex(smiles)</code>","text":"<p>Replaces dummy atoms ('*') in a SMILES string with explicit hydrogen ('H') using regex.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>The SMILES string containing dummy atoms.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A SMILES string where '[{int}*]' is replaced with '[H]'.</p> Source code in <code>src/fragmentretro/utils/helpers.py</code> <pre><code>def replace_dummy_atoms_regex(smiles: str) -&gt; str:\n    \"\"\"Replaces dummy atoms ('*') in a SMILES string with explicit hydrogen ('H') using regex.\n\n    Args:\n        smiles: The SMILES string containing dummy atoms.\n\n    Returns:\n        A SMILES string where '[{int}*]' is replaced with '[H]'.\n    \"\"\"\n    return canonicalize_smiles(re.sub(r\"\\[\\d*\\*\\]\", \"[H]\", smiles))\n</code></pre>"},{"location":"FragmentRetro/utils/helper/#fragmentretro.utils.helpers.remove_indices_before_dummy","title":"<code>remove_indices_before_dummy(smiles)</code>","text":"<p>Removes indices before asterisks (*) in a SMILES string using regex.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>The SMILES string containing indices before asterisks.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The SMILES string with indices before asterisks removed.</p> Source code in <code>src/fragmentretro/utils/helpers.py</code> <pre><code>def remove_indices_before_dummy(smiles: str) -&gt; str:\n    \"\"\"Removes indices before asterisks (*) in a SMILES string using regex.\n\n    Args:\n        smiles: The SMILES string containing indices before asterisks.\n\n    Returns:\n        The SMILES string with indices before asterisks removed.\n    \"\"\"\n    return re.sub(r\"\\[\\d*\\*\\]\", \"[*]\", smiles)\n</code></pre>"},{"location":"app/interface/","title":"FragmentRetro Interface","text":"<p>This is the GUI Implementation for FragmentRetro.</p>"},{"location":"app/interface/#example-use","title":"Example Use","text":"<p>In a Jupyter notebook:</p> <pre><code>from app.interface import display_gui\n\nimport logging\nfrom fragmentretro.utils.logging_config import logger as fragment_logger\nfrom app.logging_config import logger as app_logger\n\n# Adjust the logging levels to control the verbosity of the logs or to suppress them\nfragment_logger.setLevel(logging.WARNING)\napp_logger.setLevel(logging.INFO) \n\n# To display the GUI without any initial SMILES input\napp = display_gui()\n\n# Alternatively, to display the GUI with a predefined SMILES string\napp = display_gui(smiles=\"CCNCC\")\n</code></pre>"},{"location":"app/interface/#source-code","title":"Source Code","text":""},{"location":"app/interface/#fragmentretro.app.interface","title":"<code>fragmentretro.app.interface</code>","text":""},{"location":"app/interface/#fragmentretro.app.interface.display_gui","title":"<code>display_gui(smiles=None)</code>","text":"<p>Instantiates state, controller, connects handlers, and displays the GUI.</p> Source code in <code>src/fragmentretro/app/interface.py</code> <pre><code>def display_gui(smiles: str | None = None) -&gt; None:\n    \"\"\"Instantiates state, controller, connects handlers, and displays the GUI.\"\"\"\n\n    # 1. Instantiate State\n    app_state = AppState()\n\n    # 2. Instantiate Controller (pass state)\n    # The controller __init__ already references the imported widget instances\n    controller = GuiController(app_state)\n\n    # 3. Register Event Handlers\n    controller.register_event_handlers()\n\n    # 4. Initial UI Setup / Reset\n    if smiles:\n        target_smiles_input.value = smiles\n\n    controller.reset_ui_outputs()  # Reset UI elements via controller\n    app_state.reset_run_state()  # Reset backend state as well\n\n    # 5. Display Layout\n    display(gui_layout)  # type: ignore\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller","title":"<code>fragmentretro.app.gui.controller</code>","text":""},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController","title":"<code>GuiController</code>","text":"<p>Manages GUI event handling and interactions.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>class GuiController:\n    \"\"\"Manages GUI event handling and interactions.\"\"\"\n\n    def __init__(self, state: AppState):\n        self.state = state\n        self.target_smiles_input = target_smiles_input\n        self.fragmenter_choice = fragmenter_choice\n        self.file_path_input = file_path_input\n        self.parallelize_checkbox = parallelize_checkbox\n        self.num_cores_input = num_cores_input\n        self.core_factor_input = core_factor_input\n        self.run_button = run_button\n        self.output_area = output_area\n        self.filter_checkbox = filter_checkbox\n        self.fragment_count_input = fragment_count_input\n        self.display_button = display_button\n        self.solution_output_area = solution_output_area\n        self.solution_dropdown = solution_dropdown\n        self.image_display_area = image_display_area\n        self.fragment_comb_dropdown = fragment_comb_dropdown\n        self.smiles_display_area = smiles_display_area\n        self.prev_smiles_button = prev_smiles_button\n        self.smiles_pagination_label = smiles_pagination_label\n        self.next_smiles_button = next_smiles_button\n        self.sort_smiles_button = sort_smiles_button\n\n    def register_event_handlers(self) -&gt; None:\n        \"\"\"Connects widget events to controller methods.\"\"\"\n        self.parallelize_checkbox.observe(self.handle_parallelize_change, names=\"value\")\n        self.filter_checkbox.observe(self.handle_filter_change, names=\"value\")\n        self.run_button.on_click(self.run_retrosynthesis_on_click)\n        self.fragment_comb_dropdown.observe(self.on_fragment_comb_select, names=\"value\")\n        self.prev_smiles_button.on_click(self.on_prev_smiles_click)\n        self.next_smiles_button.on_click(self.on_next_smiles_click)\n        self.sort_smiles_button.on_click(self.on_sort_smiles_click)\n        self.display_button.on_click(self.display_solutions_on_click)\n        self.solution_dropdown.observe(self.on_solution_select, names=\"value\")\n\n    def handle_parallelize_change(self, change: dict[str, bool]) -&gt; None:\n        \"\"\"Callback to enable/disable core inputs based on parallelize checkbox.\"\"\"\n        is_parallel = change.get(\"new\", False)\n        self.num_cores_input.disabled = not is_parallel\n        self.core_factor_input.disabled = not is_parallel\n\n    def handle_filter_change(self, change: dict[str, bool]) -&gt; None:\n        \"\"\"Callback to enable/disable fragment count input based on filter checkbox.\"\"\"\n        is_filtered = change.get(\"new\", False)\n        self.fragment_count_input.disabled = not is_filtered\n        if not is_filtered:\n            self.fragment_count_input.value = None  # type: ignore\n\n    def reset_ui_outputs(self) -&gt; None:\n        \"\"\"Resets output areas, dropdowns, and buttons to their initial states.\"\"\"\n        self.solution_dropdown.options = []\n        self.solution_dropdown.value = None\n        self.solution_dropdown.disabled = True\n        self.image_display_area.clear_output(wait=False)\n        self.solution_output_area.clear_output(wait=False)\n\n        self.fragment_comb_dropdown.options = []\n        self.fragment_comb_dropdown.value = None\n        self.fragment_comb_dropdown.disabled = True\n        self.prev_smiles_button.disabled = True\n        self.next_smiles_button.disabled = True\n        self.smiles_pagination_label.value = \"0 of 0\"\n        self.sort_smiles_button.disabled = True\n        self.smiles_display_area.clear_output(wait=False)\n        with self.smiles_display_area:\n            logger.info(\"[GUI] Perform an action (Run/Display) to populate this area.\")\n\n    def run_retrosynthesis_on_click(self, b: widgets.Button) -&gt; None:\n        \"\"\"Handles the click event for the 'Run Retrosynthesis' button.\"\"\"\n        self.state.reset_run_state()\n        self.reset_ui_outputs()  # Reset UI elements\n\n        self.output_area.clear_output(wait=True)  # Clear main output specifically for run\n        with self.output_area:\n            logger.info(\"[GUI] Starting retrosynthesis...\")\n\n        target: str = self.target_smiles_input.value\n        fragmenter_name: str = self.fragmenter_choice.value\n        json_path_str: str = self.file_path_input.value\n        parallelize: bool = self.parallelize_checkbox.value\n        num_cores: int | None = self.num_cores_input.value  # type: ignore\n        core_factor: int = self.core_factor_input.value  # type: ignore\n\n        if not target:\n            with self.output_area:\n                logger.error(\"[GUI] ERROR: Target SMILES cannot be empty.\")\n            return\n\n        if json_path_str:\n            mol_properties_path = Path(json_path_str)\n            if not mol_properties_path.is_file():\n                with self.output_area:\n                    logger.error(f\"[GUI] ERROR: Properties file not found at {mol_properties_path}\")\n                return\n        try:\n            logger.info(\"[GUI] Running fragmentation...\")\n            fragmenter: Fragmenter | None = None\n            if fragmenter_name == \"BRICSFragmenter\":\n                fragmenter = BRICSFragmenter(target)\n            elif fragmenter_name == \"rBRICSFragmenter\":\n                fragmenter = rBRICSFragmenter(target)\n            else:\n                with self.output_area:\n                    logger.error(f\"[GUI] ERROR: Unknown fragmenter type '{fragmenter_name}'\")\n                return\n\n            with self.output_area:\n                logger.info(f\"[GUI] Using Fragmenter: {fragmenter_name}\")\n                logger.info(f\"[GUI] Using Properties: {mol_properties_path}\")\n                logger.info(f\"[GUI] Parallelize: {parallelize}, Num Cores: {num_cores}, Core Factor: {core_factor}\")\n\n            retro_tool = Retrosynthesis(\n                fragmenter,\n                mol_properties_path=mol_properties_path,\n                parallelize=parallelize,\n                num_cores=num_cores,\n                core_factor=core_factor,\n            )\n            with self.output_area:\n                logger.info(\"[GUI] Running retrosynthesis...\")\n                retro_tool.fragment_retrosynthesis()\n                retro_solution = RetrosynthesisSolution(retro_tool)\n                retro_solution.fill_solutions()\n                logger.info(f\"[GUI] Found {len(retro_solution.solutions)} solution(s).\")\n\n            self.state.retro_solution = retro_solution\n            self.state.retro_tool = retro_tool\n            with self.output_area:\n                logger.info(\"[GUI] Retrosynthesis complete. Ready to display solutions and browse fragment SMILES.\")\n\n        except Exception as e:\n            with self.output_area:\n                logger.error(f\"[GUI] ERROR during retrosynthesis: {e}\", exc_info=True)\n\n    def update_fragment_comb_dropdown(self, solution: SolutionType | None) -&gt; None:\n        \"\"\"Populates the fragment comb dropdown based on a single solution.\"\"\"\n        with contextlib.suppress(ValueError):\n            self.fragment_comb_dropdown.unobserve(self.on_fragment_comb_select, names=\"value\")\n\n        if solution:\n            self.fragment_comb_dropdown.options = [(str(comb), comb) for comb in solution]\n            self.fragment_comb_dropdown.disabled = False\n            self.smiles_display_area.clear_output(wait=False)\n            logger.debug(\"[GUI] Select a fragment combination to view SMILES.\")\n        else:\n            self.fragment_comb_dropdown.options = []\n            self.fragment_comb_dropdown.disabled = True\n            self.smiles_display_area.clear_output(wait=False)\n            logger.debug(\"[GUI] No fragment combinations in the selected solution.\")\n\n        self.fragment_comb_dropdown.value = None\n        self.prev_smiles_button.disabled = True\n        self.next_smiles_button.disabled = True\n        self.smiles_pagination_label.value = \"0 of 0\"\n        self.state.selected_fragment_comb = None\n        self.state.current_smiles_list = []\n        self.state.current_smiles_index = 0\n\n        self.fragment_comb_dropdown.observe(self.on_fragment_comb_select, names=\"value\")\n\n    def update_smiles_display(self) -&gt; None:\n        \"\"\"Updates the SMILES display area and pagination controls.\"\"\"\n        smiles_list: list[str] = self.state.current_smiles_list\n        index: int = self.state.current_smiles_index\n        total_smiles: int = len(smiles_list)\n\n        with self.smiles_display_area:\n            self.smiles_display_area.clear_output(wait=True)\n            if not smiles_list:\n                logger.info(\"[GUI] No SMILES found for this combination.\")\n                self.smiles_pagination_label.value = \"0 of 0\"\n                self.prev_smiles_button.disabled = True\n                self.next_smiles_button.disabled = True\n                return\n\n            current_smiles: str = smiles_list[index]\n            try:\n                mol = Chem.MolFromSmiles(current_smiles)\n                if mol:\n                    img: PILImage = Draw.MolToImage(mol, size=(300, 300))\n                    bio = io.BytesIO()\n                    img.save(bio, format=\"PNG\")\n                    image_widget = widgets.Image(value=bio.getvalue(), format=\"png\", width=300, height=300)\n                    display(image_widget)  # type: ignore\n                else:\n                    logger.warning(f\"[GUI] Invalid SMILES: {current_smiles}\")\n            except Exception as e:\n                logger.error(f\"[GUI] Error generating image for SMILES {current_smiles}: {e}\")\n\n        self.smiles_pagination_label.value = f\"{index + 1} of {total_smiles}\"\n        self.prev_smiles_button.disabled = index == 0\n        self.next_smiles_button.disabled = index &gt;= total_smiles - 1\n\n    def on_fragment_comb_select(self, change: dict[str, str | CombType]) -&gt; None:\n        \"\"\"Handles selection changes in the fragment combination dropdown.\"\"\"\n        if change.get(\"type\") == \"change\" and change.get(\"name\") == \"value\":\n            selected_comb: CombType = cast(CombType, change.get(\"new\"))\n            retro_tool: Retrosynthesis | None = self.state.retro_tool\n\n            if selected_comb is None or retro_tool is None or not hasattr(retro_tool, \"comb_bbs_dict\"):\n                self.state.reset_smiles_viewer_state()\n                self.sort_smiles_button.disabled = True\n            else:\n                smiles_data: set[str] = retro_tool.comb_bbs_dict.get(selected_comb, set())\n                smiles_list: list[str] = list(smiles_data)\n                self.state.selected_fragment_comb = selected_comb\n                self.state.current_smiles_list = smiles_list\n                self.state.current_smiles_index = 0\n                self.state.is_smiles_sorted = False\n                self.sort_smiles_button.disabled = not smiles_list\n\n            self.update_smiles_display()\n\n    def on_prev_smiles_click(self, b: widgets.Button) -&gt; None:\n        \"\"\"Handles clicks on the 'Previous' SMILES button.\"\"\"\n        if self.state.current_smiles_index &gt; 0:\n            self.state.current_smiles_index -= 1\n            self.update_smiles_display()\n\n    def on_next_smiles_click(self, b: widgets.Button) -&gt; None:\n        \"\"\"Handles clicks on the 'Next' SMILES button.\"\"\"\n        smiles_list: list[str] = self.state.current_smiles_list\n        if self.state.current_smiles_index &lt; len(smiles_list) - 1:\n            self.state.current_smiles_index += 1\n            self.update_smiles_display()\n\n    def on_sort_smiles_click(self, b: widgets.Button) -&gt; None:\n        \"\"\"Handles clicks on the 'Sort by Heavy Atoms' button.\"\"\"\n        if not self.state.is_smiles_sorted and self.state.current_smiles_list:\n            self.state.current_smiles_list = sort_by_heavy_atoms(self.state.current_smiles_list)\n            self.state.is_smiles_sorted = True\n            self.state.current_smiles_index = 0\n            self.update_smiles_display()\n            self.sort_smiles_button.disabled = True\n\n    def display_solutions_on_click(self, b: widgets.Button) -&gt; None:\n        \"\"\"Handles the click event for the 'Display Solutions' button.\"\"\"\n        self.reset_ui_outputs()  # Reset UI elements\n        self.state.reset_display_state()  # Reset backend display state\n        with self.solution_output_area:  # Log specifically to solution output area after clear\n            logger.debug(\"[GUI] Attempting to display solutions...\")\n\n        retro_solution: RetrosynthesisSolution | None = self.state.retro_solution\n        use_filter: bool = self.filter_checkbox.value\n        fragment_count: int | None = self.fragment_count_input.value if use_filter else None  # type: ignore\n\n        if retro_solution is None:\n            msg = \"No retrosynthesis results available. Please run retrosynthesis first.\"\n            with self.solution_output_area:\n                logger.warning(f\"[GUI] {msg}\")\n            return\n\n        filtered_solutions: list[SolutionType] = []\n        if use_filter and (fragment_count is None or not isinstance(fragment_count, int) or fragment_count &lt;= 0):\n            msg = \"Filter checkbox is checked, but fragment count is invalid. Displaying all solutions.\"\n            with self.solution_output_area:\n                logger.warning(f\"[GUI] {msg}\")\n            filtered_solutions = retro_solution.solutions\n        elif use_filter:\n            filtered_solutions = [sol for sol in retro_solution.solutions if len(sol) == fragment_count]\n            msg = f\"Filtering for solutions with exactly {fragment_count} fragments.\"\n            with self.solution_output_area:\n                logger.info(f\"[GUI] {msg}\")\n        else:\n            msg = \"Filter checkbox is unchecked. Displaying all available solutions.\"\n            with self.solution_output_area:\n                logger.info(f\"[GUI] {msg}\")\n            filtered_solutions = retro_solution.solutions\n\n        if not filtered_solutions:\n            msg = f\"No solutions found matching the criteria (count: {fragment_count}).\"\n            with self.solution_output_area:\n                logger.info(f\"[GUI] {msg}\")\n            return\n\n        with self.solution_output_area:\n            logger.info(f\"[GUI] Visualizing {len(filtered_solutions)} solution(s)...\")\n\n        try:\n            solution_images: list[PILImage] = retro_solution.visualize_solutions(filtered_solutions)\n            if not solution_images:\n                msg = \"Visualization did not produce any images.\"\n                with self.solution_output_area:\n                    logger.info(f\"[GUI] {msg}\")\n                return\n\n            valid_images: list[PILImage] = []\n            displayable_solutions: list[SolutionType] = []\n            original_indices: list[int] = []\n            for i, img in enumerate(solution_images):\n                if img:\n                    valid_images.append(img)\n                    current_filtered_solution = filtered_solutions[i]\n                    displayable_solutions.append(current_filtered_solution)\n                    try:\n                        original_solution_index = retro_solution.solutions.index(current_filtered_solution)\n                        original_indices.append(original_solution_index)\n                    except ValueError:\n                        with self.solution_output_area:\n                            logger.error(f\"[GUI] Could not find filtered solution {i} in original solutions list.\")\n                        original_indices.append(-1)\n                else:\n                    with self.solution_output_area:\n                        logger.warning(\n                            f\"[GUI] Null image returned by visualize_solutions for filtered solution index {i}\"\n                        )\n\n            num_valid_images = len(valid_images)\n            self.state.valid_images_cache = valid_images\n            self.state.displayable_solutions = displayable_solutions\n\n            if num_valid_images == 0:\n                msg = \"Visualization did not produce any valid images.\"\n                with self.solution_output_area:\n                    logger.info(f\"[GUI] {msg}\")\n                return\n\n            with self.solution_output_area:\n                logger.info(f\"[GUI] Generated {num_valid_images} image(s). Use dropdown to view.\")\n\n            dropdown_options: list[tuple[str, int]] = [\n                (f\"Solution {original_indices[i] + 1}\", i) for i in range(num_valid_images) if original_indices[i] != -1\n            ]\n            self.solution_dropdown.options = dropdown_options\n            self.solution_dropdown.value = 0 if dropdown_options else None\n            self.solution_dropdown.disabled = not dropdown_options\n            self.solution_dropdown.observe(self.on_solution_select, names=\"value\")\n\n            if num_valid_images &gt; 0 and self.state.displayable_solutions:\n                initial_solution: SolutionType = self.state.displayable_solutions[0]\n                self.update_fragment_comb_dropdown(initial_solution)\n            else:\n                self.update_fragment_comb_dropdown(None)\n\n            if valid_images:\n                self.image_display_area.clear_output(wait=True)\n                with self.image_display_area:\n                    display(valid_images[0])  # type: ignore\n\n            with self.solution_output_area:\n                logger.info(\"[GUI] Solutions displayed.\")\n\n        except Exception as e:\n            with self.solution_output_area:\n                logger.error(f\"[GUI] An error occurred during solution visualization: {e}\", exc_info=True)\n\n    def on_solution_select(self, change: dict[str, str | int]) -&gt; None:\n        \"\"\"Callback function for solution dropdown selection changes.\"\"\"\n        if change.get(\"type\") == \"change\" and change.get(\"name\") == \"value\":\n            selected_index: int = cast(int, change.get(\"new\"))\n            valid_images_cache: list[PILImage] = self.state.valid_images_cache\n            displayable_solutions: list[SolutionType] = self.state.displayable_solutions\n\n            if selected_index is not None and 0 &lt;= selected_index &lt; len(valid_images_cache):\n                self.image_display_area.clear_output(wait=True)\n                with self.image_display_area:\n                    display(valid_images_cache[selected_index])  # type: ignore\n\n                if selected_index &lt; len(displayable_solutions):\n                    selected_solution: SolutionType = displayable_solutions[selected_index]\n                    self.update_fragment_comb_dropdown(selected_solution)\n                    self.state.reset_smiles_viewer_state()\n                else:\n                    with self.solution_output_area:\n                        logger.warning(\n                            f\"[GUI] Selected index {selected_index} out of bounds for displayable_solutions.\"\n                        )\n                    self.update_fragment_comb_dropdown(None)\n                    self.state.reset_smiles_viewer_state()\n\n            elif selected_index is None:\n                self.image_display_area.clear_output(wait=True)\n                with self.solution_output_area:\n                    logger.info(\"[GUI] No solution selected or available.\")\n                self.update_fragment_comb_dropdown(None)\n                self.state.reset_smiles_viewer_state()\n                self.sort_smiles_button.disabled = True\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.register_event_handlers","title":"<code>register_event_handlers()</code>","text":"<p>Connects widget events to controller methods.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def register_event_handlers(self) -&gt; None:\n    \"\"\"Connects widget events to controller methods.\"\"\"\n    self.parallelize_checkbox.observe(self.handle_parallelize_change, names=\"value\")\n    self.filter_checkbox.observe(self.handle_filter_change, names=\"value\")\n    self.run_button.on_click(self.run_retrosynthesis_on_click)\n    self.fragment_comb_dropdown.observe(self.on_fragment_comb_select, names=\"value\")\n    self.prev_smiles_button.on_click(self.on_prev_smiles_click)\n    self.next_smiles_button.on_click(self.on_next_smiles_click)\n    self.sort_smiles_button.on_click(self.on_sort_smiles_click)\n    self.display_button.on_click(self.display_solutions_on_click)\n    self.solution_dropdown.observe(self.on_solution_select, names=\"value\")\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.handle_parallelize_change","title":"<code>handle_parallelize_change(change)</code>","text":"<p>Callback to enable/disable core inputs based on parallelize checkbox.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def handle_parallelize_change(self, change: dict[str, bool]) -&gt; None:\n    \"\"\"Callback to enable/disable core inputs based on parallelize checkbox.\"\"\"\n    is_parallel = change.get(\"new\", False)\n    self.num_cores_input.disabled = not is_parallel\n    self.core_factor_input.disabled = not is_parallel\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.handle_filter_change","title":"<code>handle_filter_change(change)</code>","text":"<p>Callback to enable/disable fragment count input based on filter checkbox.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def handle_filter_change(self, change: dict[str, bool]) -&gt; None:\n    \"\"\"Callback to enable/disable fragment count input based on filter checkbox.\"\"\"\n    is_filtered = change.get(\"new\", False)\n    self.fragment_count_input.disabled = not is_filtered\n    if not is_filtered:\n        self.fragment_count_input.value = None  # type: ignore\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.reset_ui_outputs","title":"<code>reset_ui_outputs()</code>","text":"<p>Resets output areas, dropdowns, and buttons to their initial states.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def reset_ui_outputs(self) -&gt; None:\n    \"\"\"Resets output areas, dropdowns, and buttons to their initial states.\"\"\"\n    self.solution_dropdown.options = []\n    self.solution_dropdown.value = None\n    self.solution_dropdown.disabled = True\n    self.image_display_area.clear_output(wait=False)\n    self.solution_output_area.clear_output(wait=False)\n\n    self.fragment_comb_dropdown.options = []\n    self.fragment_comb_dropdown.value = None\n    self.fragment_comb_dropdown.disabled = True\n    self.prev_smiles_button.disabled = True\n    self.next_smiles_button.disabled = True\n    self.smiles_pagination_label.value = \"0 of 0\"\n    self.sort_smiles_button.disabled = True\n    self.smiles_display_area.clear_output(wait=False)\n    with self.smiles_display_area:\n        logger.info(\"[GUI] Perform an action (Run/Display) to populate this area.\")\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.run_retrosynthesis_on_click","title":"<code>run_retrosynthesis_on_click(b)</code>","text":"<p>Handles the click event for the 'Run Retrosynthesis' button.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def run_retrosynthesis_on_click(self, b: widgets.Button) -&gt; None:\n    \"\"\"Handles the click event for the 'Run Retrosynthesis' button.\"\"\"\n    self.state.reset_run_state()\n    self.reset_ui_outputs()  # Reset UI elements\n\n    self.output_area.clear_output(wait=True)  # Clear main output specifically for run\n    with self.output_area:\n        logger.info(\"[GUI] Starting retrosynthesis...\")\n\n    target: str = self.target_smiles_input.value\n    fragmenter_name: str = self.fragmenter_choice.value\n    json_path_str: str = self.file_path_input.value\n    parallelize: bool = self.parallelize_checkbox.value\n    num_cores: int | None = self.num_cores_input.value  # type: ignore\n    core_factor: int = self.core_factor_input.value  # type: ignore\n\n    if not target:\n        with self.output_area:\n            logger.error(\"[GUI] ERROR: Target SMILES cannot be empty.\")\n        return\n\n    if json_path_str:\n        mol_properties_path = Path(json_path_str)\n        if not mol_properties_path.is_file():\n            with self.output_area:\n                logger.error(f\"[GUI] ERROR: Properties file not found at {mol_properties_path}\")\n            return\n    try:\n        logger.info(\"[GUI] Running fragmentation...\")\n        fragmenter: Fragmenter | None = None\n        if fragmenter_name == \"BRICSFragmenter\":\n            fragmenter = BRICSFragmenter(target)\n        elif fragmenter_name == \"rBRICSFragmenter\":\n            fragmenter = rBRICSFragmenter(target)\n        else:\n            with self.output_area:\n                logger.error(f\"[GUI] ERROR: Unknown fragmenter type '{fragmenter_name}'\")\n            return\n\n        with self.output_area:\n            logger.info(f\"[GUI] Using Fragmenter: {fragmenter_name}\")\n            logger.info(f\"[GUI] Using Properties: {mol_properties_path}\")\n            logger.info(f\"[GUI] Parallelize: {parallelize}, Num Cores: {num_cores}, Core Factor: {core_factor}\")\n\n        retro_tool = Retrosynthesis(\n            fragmenter,\n            mol_properties_path=mol_properties_path,\n            parallelize=parallelize,\n            num_cores=num_cores,\n            core_factor=core_factor,\n        )\n        with self.output_area:\n            logger.info(\"[GUI] Running retrosynthesis...\")\n            retro_tool.fragment_retrosynthesis()\n            retro_solution = RetrosynthesisSolution(retro_tool)\n            retro_solution.fill_solutions()\n            logger.info(f\"[GUI] Found {len(retro_solution.solutions)} solution(s).\")\n\n        self.state.retro_solution = retro_solution\n        self.state.retro_tool = retro_tool\n        with self.output_area:\n            logger.info(\"[GUI] Retrosynthesis complete. Ready to display solutions and browse fragment SMILES.\")\n\n    except Exception as e:\n        with self.output_area:\n            logger.error(f\"[GUI] ERROR during retrosynthesis: {e}\", exc_info=True)\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.update_fragment_comb_dropdown","title":"<code>update_fragment_comb_dropdown(solution)</code>","text":"<p>Populates the fragment comb dropdown based on a single solution.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def update_fragment_comb_dropdown(self, solution: SolutionType | None) -&gt; None:\n    \"\"\"Populates the fragment comb dropdown based on a single solution.\"\"\"\n    with contextlib.suppress(ValueError):\n        self.fragment_comb_dropdown.unobserve(self.on_fragment_comb_select, names=\"value\")\n\n    if solution:\n        self.fragment_comb_dropdown.options = [(str(comb), comb) for comb in solution]\n        self.fragment_comb_dropdown.disabled = False\n        self.smiles_display_area.clear_output(wait=False)\n        logger.debug(\"[GUI] Select a fragment combination to view SMILES.\")\n    else:\n        self.fragment_comb_dropdown.options = []\n        self.fragment_comb_dropdown.disabled = True\n        self.smiles_display_area.clear_output(wait=False)\n        logger.debug(\"[GUI] No fragment combinations in the selected solution.\")\n\n    self.fragment_comb_dropdown.value = None\n    self.prev_smiles_button.disabled = True\n    self.next_smiles_button.disabled = True\n    self.smiles_pagination_label.value = \"0 of 0\"\n    self.state.selected_fragment_comb = None\n    self.state.current_smiles_list = []\n    self.state.current_smiles_index = 0\n\n    self.fragment_comb_dropdown.observe(self.on_fragment_comb_select, names=\"value\")\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.update_smiles_display","title":"<code>update_smiles_display()</code>","text":"<p>Updates the SMILES display area and pagination controls.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def update_smiles_display(self) -&gt; None:\n    \"\"\"Updates the SMILES display area and pagination controls.\"\"\"\n    smiles_list: list[str] = self.state.current_smiles_list\n    index: int = self.state.current_smiles_index\n    total_smiles: int = len(smiles_list)\n\n    with self.smiles_display_area:\n        self.smiles_display_area.clear_output(wait=True)\n        if not smiles_list:\n            logger.info(\"[GUI] No SMILES found for this combination.\")\n            self.smiles_pagination_label.value = \"0 of 0\"\n            self.prev_smiles_button.disabled = True\n            self.next_smiles_button.disabled = True\n            return\n\n        current_smiles: str = smiles_list[index]\n        try:\n            mol = Chem.MolFromSmiles(current_smiles)\n            if mol:\n                img: PILImage = Draw.MolToImage(mol, size=(300, 300))\n                bio = io.BytesIO()\n                img.save(bio, format=\"PNG\")\n                image_widget = widgets.Image(value=bio.getvalue(), format=\"png\", width=300, height=300)\n                display(image_widget)  # type: ignore\n            else:\n                logger.warning(f\"[GUI] Invalid SMILES: {current_smiles}\")\n        except Exception as e:\n            logger.error(f\"[GUI] Error generating image for SMILES {current_smiles}: {e}\")\n\n    self.smiles_pagination_label.value = f\"{index + 1} of {total_smiles}\"\n    self.prev_smiles_button.disabled = index == 0\n    self.next_smiles_button.disabled = index &gt;= total_smiles - 1\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.on_fragment_comb_select","title":"<code>on_fragment_comb_select(change)</code>","text":"<p>Handles selection changes in the fragment combination dropdown.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def on_fragment_comb_select(self, change: dict[str, str | CombType]) -&gt; None:\n    \"\"\"Handles selection changes in the fragment combination dropdown.\"\"\"\n    if change.get(\"type\") == \"change\" and change.get(\"name\") == \"value\":\n        selected_comb: CombType = cast(CombType, change.get(\"new\"))\n        retro_tool: Retrosynthesis | None = self.state.retro_tool\n\n        if selected_comb is None or retro_tool is None or not hasattr(retro_tool, \"comb_bbs_dict\"):\n            self.state.reset_smiles_viewer_state()\n            self.sort_smiles_button.disabled = True\n        else:\n            smiles_data: set[str] = retro_tool.comb_bbs_dict.get(selected_comb, set())\n            smiles_list: list[str] = list(smiles_data)\n            self.state.selected_fragment_comb = selected_comb\n            self.state.current_smiles_list = smiles_list\n            self.state.current_smiles_index = 0\n            self.state.is_smiles_sorted = False\n            self.sort_smiles_button.disabled = not smiles_list\n\n        self.update_smiles_display()\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.on_prev_smiles_click","title":"<code>on_prev_smiles_click(b)</code>","text":"<p>Handles clicks on the 'Previous' SMILES button.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def on_prev_smiles_click(self, b: widgets.Button) -&gt; None:\n    \"\"\"Handles clicks on the 'Previous' SMILES button.\"\"\"\n    if self.state.current_smiles_index &gt; 0:\n        self.state.current_smiles_index -= 1\n        self.update_smiles_display()\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.on_next_smiles_click","title":"<code>on_next_smiles_click(b)</code>","text":"<p>Handles clicks on the 'Next' SMILES button.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def on_next_smiles_click(self, b: widgets.Button) -&gt; None:\n    \"\"\"Handles clicks on the 'Next' SMILES button.\"\"\"\n    smiles_list: list[str] = self.state.current_smiles_list\n    if self.state.current_smiles_index &lt; len(smiles_list) - 1:\n        self.state.current_smiles_index += 1\n        self.update_smiles_display()\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.on_sort_smiles_click","title":"<code>on_sort_smiles_click(b)</code>","text":"<p>Handles clicks on the 'Sort by Heavy Atoms' button.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def on_sort_smiles_click(self, b: widgets.Button) -&gt; None:\n    \"\"\"Handles clicks on the 'Sort by Heavy Atoms' button.\"\"\"\n    if not self.state.is_smiles_sorted and self.state.current_smiles_list:\n        self.state.current_smiles_list = sort_by_heavy_atoms(self.state.current_smiles_list)\n        self.state.is_smiles_sorted = True\n        self.state.current_smiles_index = 0\n        self.update_smiles_display()\n        self.sort_smiles_button.disabled = True\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.display_solutions_on_click","title":"<code>display_solutions_on_click(b)</code>","text":"<p>Handles the click event for the 'Display Solutions' button.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def display_solutions_on_click(self, b: widgets.Button) -&gt; None:\n    \"\"\"Handles the click event for the 'Display Solutions' button.\"\"\"\n    self.reset_ui_outputs()  # Reset UI elements\n    self.state.reset_display_state()  # Reset backend display state\n    with self.solution_output_area:  # Log specifically to solution output area after clear\n        logger.debug(\"[GUI] Attempting to display solutions...\")\n\n    retro_solution: RetrosynthesisSolution | None = self.state.retro_solution\n    use_filter: bool = self.filter_checkbox.value\n    fragment_count: int | None = self.fragment_count_input.value if use_filter else None  # type: ignore\n\n    if retro_solution is None:\n        msg = \"No retrosynthesis results available. Please run retrosynthesis first.\"\n        with self.solution_output_area:\n            logger.warning(f\"[GUI] {msg}\")\n        return\n\n    filtered_solutions: list[SolutionType] = []\n    if use_filter and (fragment_count is None or not isinstance(fragment_count, int) or fragment_count &lt;= 0):\n        msg = \"Filter checkbox is checked, but fragment count is invalid. Displaying all solutions.\"\n        with self.solution_output_area:\n            logger.warning(f\"[GUI] {msg}\")\n        filtered_solutions = retro_solution.solutions\n    elif use_filter:\n        filtered_solutions = [sol for sol in retro_solution.solutions if len(sol) == fragment_count]\n        msg = f\"Filtering for solutions with exactly {fragment_count} fragments.\"\n        with self.solution_output_area:\n            logger.info(f\"[GUI] {msg}\")\n    else:\n        msg = \"Filter checkbox is unchecked. Displaying all available solutions.\"\n        with self.solution_output_area:\n            logger.info(f\"[GUI] {msg}\")\n        filtered_solutions = retro_solution.solutions\n\n    if not filtered_solutions:\n        msg = f\"No solutions found matching the criteria (count: {fragment_count}).\"\n        with self.solution_output_area:\n            logger.info(f\"[GUI] {msg}\")\n        return\n\n    with self.solution_output_area:\n        logger.info(f\"[GUI] Visualizing {len(filtered_solutions)} solution(s)...\")\n\n    try:\n        solution_images: list[PILImage] = retro_solution.visualize_solutions(filtered_solutions)\n        if not solution_images:\n            msg = \"Visualization did not produce any images.\"\n            with self.solution_output_area:\n                logger.info(f\"[GUI] {msg}\")\n            return\n\n        valid_images: list[PILImage] = []\n        displayable_solutions: list[SolutionType] = []\n        original_indices: list[int] = []\n        for i, img in enumerate(solution_images):\n            if img:\n                valid_images.append(img)\n                current_filtered_solution = filtered_solutions[i]\n                displayable_solutions.append(current_filtered_solution)\n                try:\n                    original_solution_index = retro_solution.solutions.index(current_filtered_solution)\n                    original_indices.append(original_solution_index)\n                except ValueError:\n                    with self.solution_output_area:\n                        logger.error(f\"[GUI] Could not find filtered solution {i} in original solutions list.\")\n                    original_indices.append(-1)\n            else:\n                with self.solution_output_area:\n                    logger.warning(\n                        f\"[GUI] Null image returned by visualize_solutions for filtered solution index {i}\"\n                    )\n\n        num_valid_images = len(valid_images)\n        self.state.valid_images_cache = valid_images\n        self.state.displayable_solutions = displayable_solutions\n\n        if num_valid_images == 0:\n            msg = \"Visualization did not produce any valid images.\"\n            with self.solution_output_area:\n                logger.info(f\"[GUI] {msg}\")\n            return\n\n        with self.solution_output_area:\n            logger.info(f\"[GUI] Generated {num_valid_images} image(s). Use dropdown to view.\")\n\n        dropdown_options: list[tuple[str, int]] = [\n            (f\"Solution {original_indices[i] + 1}\", i) for i in range(num_valid_images) if original_indices[i] != -1\n        ]\n        self.solution_dropdown.options = dropdown_options\n        self.solution_dropdown.value = 0 if dropdown_options else None\n        self.solution_dropdown.disabled = not dropdown_options\n        self.solution_dropdown.observe(self.on_solution_select, names=\"value\")\n\n        if num_valid_images &gt; 0 and self.state.displayable_solutions:\n            initial_solution: SolutionType = self.state.displayable_solutions[0]\n            self.update_fragment_comb_dropdown(initial_solution)\n        else:\n            self.update_fragment_comb_dropdown(None)\n\n        if valid_images:\n            self.image_display_area.clear_output(wait=True)\n            with self.image_display_area:\n                display(valid_images[0])  # type: ignore\n\n        with self.solution_output_area:\n            logger.info(\"[GUI] Solutions displayed.\")\n\n    except Exception as e:\n        with self.solution_output_area:\n            logger.error(f\"[GUI] An error occurred during solution visualization: {e}\", exc_info=True)\n</code></pre>"},{"location":"app/interface/#fragmentretro.app.gui.controller.GuiController.on_solution_select","title":"<code>on_solution_select(change)</code>","text":"<p>Callback function for solution dropdown selection changes.</p> Source code in <code>src/fragmentretro/app/gui/controller.py</code> <pre><code>def on_solution_select(self, change: dict[str, str | int]) -&gt; None:\n    \"\"\"Callback function for solution dropdown selection changes.\"\"\"\n    if change.get(\"type\") == \"change\" and change.get(\"name\") == \"value\":\n        selected_index: int = cast(int, change.get(\"new\"))\n        valid_images_cache: list[PILImage] = self.state.valid_images_cache\n        displayable_solutions: list[SolutionType] = self.state.displayable_solutions\n\n        if selected_index is not None and 0 &lt;= selected_index &lt; len(valid_images_cache):\n            self.image_display_area.clear_output(wait=True)\n            with self.image_display_area:\n                display(valid_images_cache[selected_index])  # type: ignore\n\n            if selected_index &lt; len(displayable_solutions):\n                selected_solution: SolutionType = displayable_solutions[selected_index]\n                self.update_fragment_comb_dropdown(selected_solution)\n                self.state.reset_smiles_viewer_state()\n            else:\n                with self.solution_output_area:\n                    logger.warning(\n                        f\"[GUI] Selected index {selected_index} out of bounds for displayable_solutions.\"\n                    )\n                self.update_fragment_comb_dropdown(None)\n                self.state.reset_smiles_viewer_state()\n\n        elif selected_index is None:\n            self.image_display_area.clear_output(wait=True)\n            with self.solution_output_area:\n                logger.info(\"[GUI] No solution selected or available.\")\n            self.update_fragment_comb_dropdown(None)\n            self.state.reset_smiles_viewer_state()\n            self.sort_smiles_button.disabled = True\n</code></pre>"},{"location":"app/tutorial/","title":"FragmentRetro GUI Tutorial","text":"<p>This tutorial guides you through the use of the FragmentRetro Graphical User Interface (GUI). Here's a screenshot:</p> <p></p>"},{"location":"app/tutorial/#gui-components","title":"GUI Components","text":"<p>Here's a breakdown of the different sections and controls in the GUI:</p> <ol> <li> <p>Target SMILES:</p> <ul> <li>Field: Enter the SMILES string of the target molecule you want to perform retrosynthesis on.</li> <li>Example: <code>CCNCC</code></li> </ul> </li> <li> <p>Fragmenter Selection:</p> <ul> <li>Dropdown: Choose the fragmentation algorithm to use (e.g., <code>BRICSFragmenter</code>).</li> </ul> </li> <li> <p>Properties JSON:</p> <ul> <li>Field: Specify the path to the JSON file containing precomputed fragment properties.</li> <li>Example: <code>data/precompute/n1_stock_properties.json</code></li> </ul> </li> <li> <p>Parallelization Options:</p> <ul> <li>Parallelize Checkbox: Enable or disable parallel processing for substructure matching.</li> <li>Num Cores: If parallelization is enabled, specify the number of CPU cores to use.</li> <li>Core Factor: If the product of Num Cores and Core Factor is greater than the number of building blocks to match, no parallelization will occur. This is a tradeoff for parallel overhead.</li> </ul> </li> <li> <p>Run Retrosynthesis:</p> <ul> <li>Button: Click this button to start the retrosynthesis process based on the configured parameters.</li> </ul> </li> <li> <p>Log Output:</p> <ul> <li>Text Area: Displays real-time logs and status updates during the retrosynthesis process. Shows information like the fragmenter used, properties file, parallelization settings, number of solutions found, and completion status.</li> <li>Logger Suppression: To suppress log messages, use loggers to control the verbosity of the output.</li> </ul> </li> <li> <p>Display Solutions:</p> <ul> <li>Filter Solutions Checkbox: Enable filtering of displayed solutions based on the number of fragments.</li> <li>Number of Fragments: If filtering is enabled, enter the desired number of fragments to filter by. A value of <code>0</code> or invalid input usually displays all solutions.</li> <li>Display Solutions Button: Click to update the solution display based on the filter settings.</li> <li>Select Solution Dropdown: Choose a specific retrosynthesis solution to view its details. Example: <code>Solution 3</code></li> </ul> </li> <li> <p>Selected Solution Visualization:</p> <ul> <li>Image Area: This area displays the chemical structures of the fragments corresponding to the selected solution, with each fragment accompanied by its associated connection points (e.g., <code>4*</code>, <code>5*</code>).</li> <li>Text: This section displays the SMILES strings and combination indices for the fragments in the selected solution. Example: <code>(0,): [4*]CC</code>, <code>(1, 2): [5*]NCC</code></li> </ul> </li> <li> <p>Browse Building Blocks:</p> <ul> <li>Select Fragment Comb: This option allows you to select the indices of fragments (comma-separated) to visualize the fragment combinations of a chosen solution. Example: <code>(1, 2)</code></li> <li>Image Area: This area displays the building blocks that have substructure matches with the chosen fragments (fragment combinations).</li> </ul> </li> <li> <p>Pagination Controls (for Building Blocks):</p> <ul> <li>Previous/Next Buttons: These buttons enable navigation through different possible building block matches if there are many.</li> <li>Counter: This counter shows the current building block being viewed out of the total. Example: <code>5 of 25</code></li> </ul> </li> <li> <p>Sorting Options:</p> <ul> <li>Sort by Heavy Atoms Checkbox: This option allows you to sort the visualized building blocks by the number of heavy atoms.</li> </ul> </li> </ol> <p>This covers the main elements of the FragmentRetro GUI. Use these controls to input your target molecule, configure the parameters, run the retrosynthesis, and explore the resulting fragmentation solutions.</p>"},{"location":"dev/TODO/","title":"To-Do List","text":""},{"location":"dev/TODO/#fragmentretro","title":"FragmentRetro","text":"<ul> <li> Finish <code>Retrosynthesis</code> class</li> <li> Create a <code>Solution</code> class to visualize retrosynthesis \"solutions\".</li> <li> Rewrite <code>is_substructure_BBs</code> such that BBs change at every stage (take out unnecessary BBs).</li> <li> Write tests for the <code>CompoundFilter</code> class (with or without filter should work the same for substructure matcher)</li> <li> Write tests for the <code>RetrosynthesisSolution</code> class</li> <li> Write tests for the parallelization of substructure matcher</li> <li> Write tests for <code>BRICSFragmenter</code>.</li> <li> Write tests for <code>get_combination_smiles</code>.</li> <li> Ignore chirality at the neighbor of dummy atoms for <code>is_strict_substructure</code>.</li> <li> Confirm that <code>SubstructureMatcher.addH_to_wildcard_neighbors</code> is the most efficient way to do <code>is_strict_substructure</code>.</li> <li> Write tests for the <code>Retrosynthesis</code> class</li> </ul>"},{"location":"dev/TODO/#new-fragmentation-rules","title":"New Fragmentation Rules","text":"<ul> <li> Come up with ring fragmentation rules that covers enough common types of rings in drug-like compounds.</li> </ul>"},{"location":"dev/introduction/","title":"Introduction","text":""},{"location":"dev/introduction/#development","title":"Development","text":"<p>If you need other packages to run your features, you must specify the dependency in <code>pyproject.toml</code> and the version used. If you run</p> <pre><code>uv add package\n</code></pre> <p>pyproject.toml will be updated automatically.</p>"},{"location":"dev/introduction/#set-up","title":"Set Up","text":"<pre><code>uv venv\n</code></pre> <p>which will create a new virtual environment (in the folder <code>venv</code> which is already gitignored).</p> <p>Activate the environment:</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>and install all dependencies (specified in <code>pyproject.toml</code>):</p> <pre><code>uv pip install -e \".[dev]\"\n</code></pre>"},{"location":"dev/introduction/#cloning-setting-pre-commits","title":"Cloning &amp; Setting Pre-commits","text":"<ol> <li>Clone the repository.</li> <li>Inside of the repository, run <code>pre-commit install</code></li> <li>Create a new branch <code>git branch nameofthebranch</code> and switch to it <code>git checkout nameofthebranch</code>.</li> <li>Whenever you want to push the commits to the repo, do <code>git push -u origin nameofthebranch</code></li> </ol>"},{"location":"dev/introduction/#pre-commits","title":"Pre-Commits","text":"<p>After <code>pre-commit install</code>, each time you try to make a commit, the system will automatically check for formatting and linting errors (using ruff)</p> <p>mypy from pre-commit hooks currently disabled just so that you can push commits even with failing mypy so that we can discuss it on GitHub and see how it can be fixed</p> <p>If any of the checks above (ruff) fail, the system will try to fix them automatically, so in most cases you'll only need to run <code>git add .</code> and try to commit again. If you want run the checks manually, you can do:</p> <ul> <li><code>ruff check</code>. If there are errors, most of the time they can be fixed by <code>ruff check --fix</code>. Some errors will need to be fixed manually though.</li> <li><code>ruff format</code> to format the code according to the Black style guide. </li> </ul>"},{"location":"dev/introduction/#mypy","title":"MyPy","text":"<p>Python 3.5 introduced type annotations (PEP 484) and MyPy is the official type checker. You can add a VSCode/Cursor extension that will highlight most of the type issues. Getting Started page in official docs is a good introduction to MyPy. Basically you specify the types for function arguments/outputs, which makes code easier to understand and helps catch issues with code early on.</p>"},{"location":"dev/introduction/#commit-prefixes","title":"Commit Prefixes","text":"<ul> <li>FEAT: - new features</li> <li>FIX: bug and other fixes on existing code</li> <li>DOCS: - any changes to readme, comments, docstrings etc</li> <li>STYLE: any style improvements, like refactoring, adding type hints, better namings etc</li> <li>DEV: intermediate commits, ideally these are on non-main branch. Basically every code after FEAT/FIX/DOCS/STYLE should be assumed to work correctly (to the best of your knowledge). DEV Is commits you do when working towards something that will become a FEAT/FIX on a main</li> </ul>"},{"location":"dev/introduction/#acknowledgement","title":"Acknowledgement","text":"<p>We made slight modifications to the project workflow, MkDocs setup, developer guides, and logging practices introduced by Anton Morgunov.</p>"},{"location":"dev/logging/","title":"Logging Best Practices","text":"<p>This guide explains how to effectively use Python's logging module in this codebase, whether you're writing modules, running scripts from CLI, or working in Jupyter notebooks.</p>"},{"location":"dev/logging/#environment-variables","title":"Environment Variables","text":"<p>The application's log level can be controlled using the <code>FRAGMENT_LOG_LEVEL</code> environment variable:</p> <pre><code># Set log level for the current session\nexport FRAGMENT_LOG_LEVEL=DEBUG\npython your_script.py\n\n# Or set it for a single command\nFRAGMENT_LOG_LEVEL=DEBUG python your_script.py\n</code></pre> <p>Valid log levels are:</p> <ul> <li><code>DEBUG</code>: Most verbose, detailed debugging information</li> <li><code>INFO</code>: General operational information (default)</li> <li><code>WARNING</code>: Unexpected situations that aren't errors</li> <li><code>ERROR</code>: Serious problems that need attention</li> <li><code>CRITICAL</code>: Critical issues that may cause program failure</li> </ul>"},{"location":"dev/logging/#module-development","title":"Module Development","text":"<p>When writing a module, follow these guidelines:</p> <pre><code>from fragmentretro.utils.logging_config import logger\n\ndef my_function():\n    # Use appropriate log levels\n    logger.debug(\"Detailed information for debugging\")\n    logger.info(\"General information about progress\")\n    logger.warning(\"Something unexpected but not error\")\n    logger.error(\"A more serious problem\")\n    logger.critical(\"Program may not be able to continue\")\n</code></pre> <p>Key points:</p> <ul> <li>Don't configure the logger in your modules</li> <li>Always use <code>from fragmentretro.utils.logging_config import logger</code></li> <li>Choose appropriate log levels</li> <li>Don't use print statements for debugging</li> <li>Don't add parameters like <code>verbose</code> to your functions</li> </ul>"},{"location":"dev/logging/#jupyter-notebook-usage","title":"Jupyter Notebook Usage","text":"<p>For Jupyter notebooks, put this in your first cell:</p> <pre><code>from fragmentretro.utils.logging_config import logger\n\nlogger.setLevel(logging.DEBUG)  # To see debug messages\nlogger.setLevel(logging.INFO)   # Back to info only\n</code></pre>"},{"location":"dev/logging/#log-levels-guide","title":"Log Levels Guide","text":"<p>Choose the appropriate level based on the message importance:</p> <ul> <li>DEBUG: Detailed information for diagnosing problems</li> </ul> <pre><code>logger.debug(f\"Processing data frame with shape {df.shape}\")\n</code></pre> <ul> <li>INFO: Confirmation that things are working as expected</li> </ul> <pre><code>logger.info(\"Model training started\")\n</code></pre> <ul> <li>WARNING: Indication that something unexpected happened</li> </ul> <pre><code>logger.warning(\"Using fallback parameter value\")\n</code></pre> <ul> <li>ERROR: More serious problem that prevented function from working</li> </ul> <pre><code>logger.error(\"Failed to load model weights\")\n</code></pre> <ul> <li>CRITICAL: Program may not be able to continue</li> </ul> <pre><code>logger.critical(\"Out of memory - cannot continue processing\")\n</code></pre>"},{"location":"dev/logging/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li> <p>Configuring Loggers in Modules: Only configure logging in your entry points (main scripts, notebooks)</p> </li> <li> <p>Using Print Statements: Avoid print statements for debugging; use logger.debug instead</p> </li> <li> <p>Hard-coding Log Levels: Don't set log levels in your modules; let the application control them</p> </li> <li> <p>Creating Multiple Handlers: Clear existing handlers in notebooks to avoid duplicate logs</p> </li> <li> <p>Using f-strings for Debug Messages: For expensive operations, check level first:</p> </li> </ol> <pre><code># Bad (string formatting happens regardless of level)\nlogger.debug(f\"Expensive operation result: {expensive_operation()}\")\n\n# Good (string formatting only happens if needed)\nif logger.isEnabledFor(logging.DEBUG):\n    logger.debug(f\"Expensive operation result: {expensive_operation()}\")\n</code></pre>"},{"location":"dev/mkdocs/","title":"MkDocs","text":"<p>For full documentation of mkdocs use visit mkdocs.org.</p>"},{"location":"dev/mkdocs/#instructions","title":"Instructions","text":"<p>To see rendered docs on your laptop, run <code>mkdocs serve</code> in project root folder. The output will specify on which port of localhost the docs are rendered.</p> <p>For every conceptually independent module, create (if it doesn't exist already) a new folder. In that folder, create <code>.md</code> files with the documentation. Try to follow this structure:</p> <pre><code># Title\n\nsome high-level description, everything which is worth documenting\n\n## Example Use\n\nself-explanatory\n\n## Source Code\n\nThis part can actually be self-populated.\n</code></pre>"}]}